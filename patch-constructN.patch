From 3e1fd0bfaa5f9bf76c97b2180fe9b063b41a4b9d Mon Sep 17 00:00:00 2001
From: m-schuetz <markus_schuetz@gmx.at>
Date: Mon, 13 Feb 2023 09:10:48 +0100
Subject: [PATCH 01/13] update sponsors

---
 README.md                              |   3 +++
 docs/sponsors/kokusaikogyo_logo_02.jpg | Bin 0 -> 79418 bytes
 2 files changed, 3 insertions(+)
 create mode 100644 docs/sponsors/kokusaikogyo_logo_02.jpg

diff --git a/README.md b/README.md
index fcc15159..abac87bc 100644
--- a/README.md
+++ b/README.md
@@ -481,6 +481,9 @@ We would like to thank our sponsors for their financial contributions that keep
 			â‚¬ 1,000+
 		</th>
 		<td>
+			<a href="https://www.kkc.co.jp/english/index.html/">
+				<img src="docs/sponsors/kokusaikogyo_logo_02.jpg" height="40"/> &nbsp;
+			</a>
 			<a href="https://www.unstruk.com/">
 				<img src="docs/sponsors/unstruk.png" height="33"/> &nbsp;
 			</a>
diff --git a/docs/sponsors/kokusaikogyo_logo_02.jpg b/docs/sponsors/kokusaikogyo_logo_02.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..c8eed9348c9a4b819b2c8a32142bd582acb867ec
GIT binary patch
literal 79418
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
NlFA9X?Wz9%O#n-IWRU;>

literal 0
HcmV?d00001

-- 
2.38.1.windows.1


From 092ebb2cd835b64127cfb2a283b34459fdbff1bc Mon Sep 17 00:00:00 2001
From: VictorPA <sfggeogis@gmail.com>
Date: Thu, 30 Mar 2023 10:26:06 +0200
Subject: [PATCH 02/13] add catalan translation

---
 resources/lang/ca/translation.json | 108 +++++++++++++++++++++++++++++
 src/viewer/sidebar.js              |   3 +-
 src/viewer/viewer.js               |   2 +-
 3 files changed, 111 insertions(+), 2 deletions(-)
 create mode 100644 resources/lang/ca/translation.json

diff --git a/resources/lang/ca/translation.json b/resources/lang/ca/translation.json
new file mode 100644
index 00000000..b701137f
--- /dev/null
+++ b/resources/lang/ca/translation.json
@@ -0,0 +1,108 @@
+{
+	"tb": {
+		"navigation_opt": "NavegaciÃ³",
+		"rendering_opt": "VisualitzaciÃ³",
+		"tools_opt": "Eines",
+		"measurments_opt": "Mesures",
+		"clipping_opt": "Retall",
+		"annotations_opt": "Anotacions",
+		"materials_opt": "Materials",
+		"scene_opt": "Capes",
+		"properties_opt": "Propietats de la capa",
+		"classification_filter_opt": "ClassificaciÃ³ per filtres",
+		"filters_opt": "Filtres",
+		"parameters_opt": "Altres configuracions",
+		"info_opt": "InformaciÃ³ de les dades",
+		"about_opt": "InformaciÃ³ sobre el visor"
+	},
+	"tt": {
+		"angle_measurement": "Angle",
+		"point_measurement": "Coordenada del punt",
+		"distance_measurement": "DistÃ ncia",
+		"height_measurement": "AlÃ§ada",
+		"circle_measurement": "DimensiÃ³ del cercle",
+		"area_measurement": "Ã€rea",
+		"volume_measurement": "Volum",
+		"height_profile": "Perfil 2D",
+		"annotation": "AnnotaciÃ³",
+		"clip_volume": "Retall de volum",
+		"clip_polygon": "Retall de polÃ­gon",
+		"screen_clip_box": "Dibuixeu un quadre de selecciÃ³. Cal estar en mode de cÃ mera ortogrÃ fica",
+		"clip_plane_x": "Pla del retall en l'eix x",
+		"clip_plane_y": "Pla del retall en l'eix y",
+		"clip_plane_z": "Pla del retall en l'eix z",
+		"remove_all_measurement": "Eliminar totes les mesures",
+		"left_view_control": "Vista esquerra",
+		"right_view_control": "Vista dreta",
+		"front_view_control": "Vista frontal",
+		"back_view_control": "Vista posterior",
+		"top_view_control": "Vista superior",
+		"bottom_view_control": "Vista inferior",
+		"focus_control": "Vista completa",
+		"orbit_control": "Control orbital",
+		"flight_control": "Control de vol",
+		"heli_control": "Control d'helicÃ²pter",
+		"earth_control": "Control espacial",
+		"perspective_camera_control": "Perspectiva de la camera",
+		"orthographic_camera_control": "Camera ortogrÃ fica",
+		"navigation_cube_control": "Cub de navegaciÃ³",
+		"remove_all_clipping_volumes": "Eliminar tots els volums retallats",
+		"compass": "BrÃºixola",
+		"camera_animation": "Moviment de cÃ mera" 
+	},
+	"appearance": {
+		"nb_max_pts": "Densitat de punts", 
+		"point_size": "Mida del punt",
+		"min_point_size": "Mida mÃ­nima del punt",
+		"point_opacity": "Opacitat",
+		"field_view": "Zoom",
+		"point_size_type": "Tamany del punt",
+		"point_material": "Textura",
+		"elevation_range": "Rang d'elevaciÃ³",
+		"extra_range": "Rang escalar",
+		"point_quality": "Qualitat",
+		"point_shape": "Forma del punt",
+		"edl_radius": "Radi",
+		"edl_strength": "DistÃ ncia",
+		"edl_opacity": "Opacity",
+		"edl_enable": "Habilitar",
+		"min_node_size": "Mida de node mÃ­nima",
+		"clip_mode": "Mode retall",
+		"move_speed": "Velocitat de moviment",
+		"skybox": "Cel",
+		"bottom_lock": "Mantenir-se sobre el terra",
+		"box": "Caixa",
+		"length_unit": "Unitats de mesura",
+		"freeze": "Bloquejar la vista",
+		"language": "Idioma",
+		"backface_culling": "EliminaciÃ³ de la cara posterior"
+	},
+	"measurements": {
+		"clip": "Retall",
+		"show": "Veure el volum"
+	},
+	"annotations": {
+		"show3D": "Veure en 3D",
+		"showMap": "Veure al mapa"
+	}, 
+	"profile": {
+		"nb_points": "Nombre de punts",
+		"title": "Perfil en alÃ§ada",
+		"save_las": "Desar LAS(3D)",
+		"save_ortho": "Desar CSV(2D)"
+	},
+	"scene": {
+		"camera_position": "PosiciÃ³ de la camera",
+		"camera_target": "Objectiu de la camera"
+	},
+	"filters": {
+		"return_number": "NÃºmero de retorn",
+		"number_of_returns": "Nombre de Retorns",
+		"gps_min": "min",
+		"gps_max": "mÃ x",
+		"gps_time": "Temps GPS"
+	},
+	"settings": {
+		"language": "Idioma"
+	}
+}
diff --git a/src/viewer/sidebar.js b/src/viewer/sidebar.js
index 7781ea26..7200f6e5 100644
--- a/src/viewer/sidebar.js
+++ b/src/viewer/sidebar.js
@@ -1242,7 +1242,8 @@ export class Sidebar{
 			["ES", "es"],
 			["SE", "se"],
 			["ZH", "zh"],
-			["IT", "it"]
+			["IT", "it"],
+			["CA", "ca"]
 		];
 
 		let elLanguages = $('#potree_languages');
diff --git a/src/viewer/viewer.js b/src/viewer/viewer.js
index 1f20fdc1..baf1fb1b 100644
--- a/src/viewer/viewer.js
+++ b/src/viewer/viewer.js
@@ -1269,7 +1269,7 @@ export class Viewer extends EventDispatcher{
 			i18n.init({
 				lng: 'en',
 				resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
-				preload: ['en', 'fr', 'de', 'jp', 'se', 'es', 'zh', 'it'],
+				preload: ['en', 'fr', 'de', 'jp', 'se', 'es', 'zh', 'it','ca'],
 				getAsync: true,
 				debug: false
 			}, function (t) {
-- 
2.38.1.windows.1


From 255ec3d4fbc8c841288d2f5cb5f447824ec165ba Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 14 Jun 2023 17:21:46 +0530
Subject: [PATCH 03/13] code enhancements completed

---
 commands.txt                                  |   19 +
 examples/colorextension.js                    |  109 +
 examples/colorextension_optimized.js          |   52 +
 examples/dtwin_viewer_v0.html                 | 3603 +++++++++++++++++
 examples/lion_las.html                        |  445 +-
 src/modules/Images360/Images360.js            |  643 ++-
 .../OrientedImages/OrientedImageControls.js   |   37 +-
 src/modules/OrientedImages/OrientedImages.js  |  902 ++---
 src/navigation/OrbitControls.js               |  580 +--
 src/viewer/Scene.js                           |  885 ++--
 src/viewer/map.js                             |    2 +-
 src/viewer/viewer.js                          |  172 +-
 12 files changed, 5784 insertions(+), 1665 deletions(-)
 create mode 100644 commands.txt
 create mode 100644 examples/colorextension.js
 create mode 100644 examples/colorextension_optimized.js
 create mode 100644 examples/dtwin_viewer_v0.html

diff --git a/commands.txt b/commands.txt
new file mode 100644
index 00000000..ddfbd1a3
--- /dev/null
+++ b/commands.txt
@@ -0,0 +1,19 @@
+curl -v 'https://developer.api.autodesk.com/authentication/v1/authenticate' -X 'POST' -H 'Content-Type: application/x-www-form-urlencoded' -d 'client_id=aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM&client_secret=mSqemcEE53l4THBJ&grant_type=client_credentials&scope=data:read%20data:write%20viewables:read%20bucket:create%20bucket:read'
+
+eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA
+
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets' -X 'POST' -H 'Content-Type: application/json' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsImtpZCI6Imp3dF9zeW1tZXRyaWNfa2V5In0.eyJjbGllbnRfaWQiOiJpWFdZbTNGVkdNaExZTHNzQVFBd2RNR01xNUhzQXdOYiIsImV4cCI6MTU4NTEyMTY0NSwic2NvcGUiOlsiZGF0YTpyZWFkIiwiZGF0YTp3cml0ZSIsInZpZXdhYmxlczpyZWFkIiwiYnVja2V0OmNyZWF0ZSIsImJ1Y2tldDpyZWFkIl0sImF1ZCI6Imh0dHBzOi8vYXV0b2Rlc2suY29tL2F1ZC9qd3RleHA2MCIsImp0aSI6Im10VklEWGtrOUJwUVBUYU84UlpEV3NWNWpCSHR3VkRObUIwVlN3dnJVeXFiNTVveFlibW5vaUNsMk02Vks4Ym4ifQ.71YkbtExiXDVkWeGODigBWGViNj9_5RSHwTjgvd_MME' -d '{"bucketKey":"threeforge","policyKey":"transient"}'
+digitaltwins
+Verify Bucket
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/details' -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA'
+
+
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/objects/floor_4.ifc' -X 'PUT' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/octet-stream' -T 'floor_4.ifc'
+
+urn:adsk.objects:os.object:dtwin/floor_4.ifc
+
+dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=
+
+curl -X 'POST' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/json' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/job' -d '{"input": {"urn": "dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM="},"output":{"formats":[{"type":"svf","views":["2d","3d"]}]}}'
+
+curl -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=/manifest'
\ No newline at end of file
diff --git a/examples/colorextension.js b/examples/colorextension.js
new file mode 100644
index 00000000..a1bdf86f
--- /dev/null
+++ b/examples/colorextension.js
@@ -0,0 +1,109 @@
+///////////////////////////////////////////////////////////////////////////////
+// Autodesk.ADN.Viewing.Extension.Color
+//
+///////////////////////////////////////////////////////////////////////////////
+AutodeskNamespace("Autodesk.ADN.Viewing.Extension");
+Autodesk.ADN.Viewing.Extension.Color = function(viewer, options) {
+
+    Autodesk.Viewing.Extension.call(this, viewer, options);
+
+    var overlayName = "temperary-colored-overlay";
+    var _self = this;
+    var defMaterials = {}
+
+    _self.load = function() {
+
+        console.log('Autodesk.ADN.Viewing.Extension.Color loaded');
+        ///////////////////////////////////////////////////////////////////////////
+        // Generate GUID
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        // function newGuid() {
+        //     var d = new Date().getTime();
+        //     var guid = 'xxxx-xxxx-xxxx-xxxx-xxxx'.replace(/[xy]/g, function(c) {
+        //         var r = (d + Math.random() * 16) % 16 | 0;
+        //         d = Math.floor(d / 16);
+        //         return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);
+        //     });
+        //     return guid;
+        // };
+
+        ///////////////////////////////////////////////////////////////////////////
+        // add new material
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        function addMaterial(color, name) {
+            var material =  new THREE.MeshPhongMaterial({side: THREE.DoubleSide, color, opacity: 1, transparent: false})
+            viewer.impl.matman().addMaterial(name, material);
+            // viewer.impl.createOverlayScene(name, material, material);
+            return material;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Set color for nodes
+        // objectIds should be an array of dbId
+        // 
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        Autodesk.Viewing.Viewer3D.prototype.setColorMaterial = function(objectIds, color, name) {
+            var material = addMaterial(color, name);
+            const frags = viewer.model.getFragmentList();
+            for (var i=0; i<objectIds.length; i++) {
+
+                var dbid = objectIds[i];
+
+                //from dbid to node, to fragid
+                var it = viewer.model.getData().instanceTree;
+
+                it.enumNodeFragments(dbid, function (fragId) {
+    
+                    defMaterials[dbid] = viewer.model.getFragmentList().getMaterial(fragId);
+                    // var renderProxy = viewer.impl.getRenderProxy(viewer.model, fragId);
+                    
+                    // renderProxy.meshProxy = new THREE.Mesh(renderProxy.geometry, renderProxy.material);
+
+                    // renderProxy.meshProxy.matrix.copy(renderProxy.matrixWorld);
+                    // renderProxy.meshProxy.matrixWorldNeedsUpdate = true;
+                    // renderProxy.meshProxy.matrixAutoUpdate = false;
+                    // renderProxy.meshProxy.frustumCulled = false;
+
+                    // viewer.impl.addOverlay(name, renderProxy.meshProxy);
+                    frags.setMaterial(fragId, material);
+                    viewer.impl.invalidate(true);
+                    
+                }, false);
+            }
+
+        }
+
+
+        Autodesk.Viewing.Viewer3D.prototype.restoreColorMaterial = function(objectIds) {
+       
+            const frags = viewer.model.getFragmentList();
+            for (var i=0; i<objectIds.length; i++) {
+
+                var dbid = objectIds[i];
+
+                //from dbid to node, to fragid
+                var it = viewer.model.getData().instanceTree;
+
+                it.enumNodeFragments(dbid, function (fragId) {
+                    if (defMaterials[dbid]) {
+                        frags.setMaterial(fragId, defMaterials[dbid]);
+                        viewer.impl.invalidate(true);
+                    }
+                    
+                }, false);
+            }
+  
+        }
+
+        _self.unload = function() {
+            console.log('Autodesk.ADN.Viewing.Extension.Color unloaded');
+            return true;
+        };
+    };
+};
+Autodesk.ADN.Viewing.Extension.Color.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
+Autodesk.ADN.Viewing.Extension.Color.prototype.constructor = Autodesk.ADN.Viewing.Extension.Color;
+Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.ADN.Viewing.Extension.Color', Autodesk.ADN.Viewing.Extension.Color);
\ No newline at end of file
diff --git a/examples/colorextension_optimized.js b/examples/colorextension_optimized.js
new file mode 100644
index 00000000..15ac71c9
--- /dev/null
+++ b/examples/colorextension_optimized.js
@@ -0,0 +1,52 @@
+AutodeskNamespace("Autodesk.ADN.Viewing.Extension");
+Autodesk.ADN.Viewing.Extension.Color = function(viewer, options) {
+
+    Autodesk.Viewing.Extension.call(this, viewer, options);
+
+    var overlayName = "temperary-colored-overlay";
+    var _self = this;
+    var defMaterials = {}
+    var materials = {}
+
+    _self.load = function() {
+
+        console.log('Autodesk.ADN.Viewing.Extension.Color loaded');
+        
+        function addMaterial(color, name) {
+            if (name in materials){
+                return materials[name]
+            } else {
+                console.log('Creating Material for ', name)
+                const material = new THREE.Vector4(color[0], color[1], color[2], color[3]);
+                materials[name] = material
+                return material;
+            }
+
+        }
+
+        Autodesk.Viewing.Viewer3D.prototype.setColorMaterial = function(objectIds, color, name) {
+            var material = addMaterial(color, name);
+            const frags = viewer.model.getFragmentList();
+            //from dbid to node, to fragid
+            var it = viewer.model.getData().instanceTree;
+            for (var i=0; i<objectIds.length; i++) {
+                var dbid = objectIds[i];
+                viewer.setThemingColor(dbid, material, null, true);
+            }
+            viewer.impl.invalidate(true);
+        }
+
+        Autodesk.Viewing.Viewer3D.prototype.restoreColorMaterial = function(objectIds) {
+            viewer.clearThemingColors();
+            viewer.impl.invalidate(true);
+        }
+
+        _self.unload = function() {
+            console.log('Autodesk.ADN.Viewing.Extension.Color unloaded');
+            return true;
+        };
+    };
+};
+Autodesk.ADN.Viewing.Extension.Color.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
+Autodesk.ADN.Viewing.Extension.Color.prototype.constructor = Autodesk.ADN.Viewing.Extension.Color;
+Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.ADN.Viewing.Extension.Color', Autodesk.ADN.Viewing.Extension.Color);
\ No newline at end of file
diff --git a/examples/dtwin_viewer_v0.html b/examples/dtwin_viewer_v0.html
new file mode 100644
index 00000000..0624ae6a
--- /dev/null
+++ b/examples/dtwin_viewer_v0.html
@@ -0,0 +1,3603 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8" />
+    <meta name="description" content="" />
+    <meta name="author" content="" />
+    <meta
+      name="viewport"
+      content="width=device-width, initial-scale=1.0, user-scalable=no"
+    />
+    <title>Potree Viewer</title>
+
+    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jquery-ui/jquery-ui.min.css"
+    />
+    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/spectrum/spectrum.css"
+    />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jstree/themes/mixed/style.css"
+    />
+    <link
+      rel="stylesheet"
+      href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css"
+      type="text/css"
+    />
+    <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>
+    <link
+      rel="stylesheet"
+      href="https://fonts.googleapis.com/icon?family=Material+Icons"
+    />
+    <link
+      rel="stylesheet"
+      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"
+    />
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
+    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
+    <script src="./colorextension_optimized.js"></script>
+    <script>
+      (function (h, o, t, j, a, r) {
+        h.hj =
+          h.hj ||
+          function () {
+            (h.hj.q = h.hj.q || []).push(arguments);
+          };
+        h._hjSettings = { hjid: 2746579, hjsv: 6 };
+        a = o.getElementsByTagName("head")[0];
+        r = o.createElement("script");
+        r.async = 1;
+        r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
+        a.appendChild(r);
+      })(window, document, "https://static.hotjar.com/c/hotjar-", ".js?sv=");
+    </script>
+    <style>
+      .dropup .dropdown-menu,
+      .navbar-fixed-bottom .dropdown .dropdown-menu {
+        bottom: 5%;
+        background-color: rgba(34, 34, 34, 0.94);
+      }
+      .dropdown-menu {
+        min-width: 230px;
+        left: 50px;
+      }
+      .panoIcon {
+        background: greenyellow;
+        border-radius: 100%;
+        position: absolute;
+        z-index: 101;
+        opacity: 0.7;
+      }
+
+      .panoIcon:hover {
+        background: rgb(0, 217, 255);
+        cursor: pointer;
+        opacity: 1;
+      }
+
+      .userIcon {
+        width: 20px;
+        height: 20px;
+        position: absolute;
+        z-index: 1000;
+      }
+
+      .actionIcon {
+        font-size: 50px;
+        /* border-style: double; */
+        color: white;
+        border-radius: 10px;
+        background-color: rgba(34, 34, 34, 0.94);
+        display: inline-block;
+        position: relative;
+      }
+
+      .actionIcon:hover {
+        cursor: pointer;
+      }
+
+      .fpFullScreen {
+        position: absolute;
+        top: 1%;
+        right: 1%;
+      }
+
+      .fpFullScreen:hover {
+        cursor: pointer;
+      }
+
+      .actionButtons {
+        position: absolute;
+        bottom: 10px;
+        width: calc(100% - 20px);
+        height: 50px;
+        text-align: center;
+        z-index: 100;
+        display: none;
+      }
+
+      .floormap {
+        position: absolute;
+        right: 0px;
+        top: 10px;
+        z-index: 100;
+        display: none;
+      }
+
+      .goto3d {
+        right: 2%;
+        position: absolute;
+        display: none;
+      }
+
+      .noBIM {
+        background: #e1e1e1;
+        margin: 0 auto;
+        position: absolute;
+        z-index: 200;
+        top: 25%;
+        left: 25%;
+        height: calc(100% - 50%);
+        width: calc(100% - 50%);
+        padding: 30px;
+        -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        -moz-box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        display: none;
+        text-align: center;
+        vertical-align: middle;
+      }
+      .utility_icons {
+        position: relative;
+        cursor: pointer;
+        padding: 6px;
+        margin: 4px;
+        border: 1px solid rgba(34, 34, 34, 0);
+        border-radius: 4px;
+        display: inline-block;
+        padding-top: 3px;
+        font-size: 24px;
+        line-height: 1;
+        background-repeat: no-repeat;
+        background-position: 50%;
+      }
+      .actionButtonsTest {
+        color: #f4f4f4;
+        background-color: rgba(34, 34, 34, 0.94);
+        box-shadow: 1px 3px 10px 0 rgb(0 0 0 / 50%);
+        position: relative;
+        float: left;
+        cursor: pointer;
+        padding: 6px;
+        margin: 4px;
+        border: 1px solid rgba(34, 34, 34, 0);
+        border-radius: 4px;
+      }
+      .icon-test {
+        padding: 5px;
+      }
+      .icon-test:hover {
+        color: #f5ca52;
+        border: 1px solid #f5ca52;
+      }
+      .icon-test:focus {
+        color: #f5ca52;
+        outline: none;
+        border-radius: 3px;
+        box-shadow: inset 0 2px 2px 0 #000;
+      }
+      .s3-icon {
+        width: 30px;
+        height: 30px;
+        margin: 2px;
+      }
+      #datepickerLeft,
+      #datepickerRight {
+        color: #000;
+        padding: 4px;
+        margin-right: 5px;
+      }
+      .closeBtn {
+        position: absolute;
+        float: left;
+        z-index: 9;
+      }
+      .bim-legend-container {
+        right: 10px;
+        bottom: 10px;
+        position: absolute;
+        background-color: rgba(34, 34, 34, 0.94);
+        z-index: 2;
+        display: none;
+      }
+
+      .bim-legend {
+        list-style: none;
+      }
+      .bim-legend li {
+        margin-right: 10px;
+        color: #f4f4f4;
+        cursor: pointer;
+      }
+      .bim-legend span {
+        border: 1px solid #ccc;
+        float: left;
+        width: 12px;
+        height: 12px;
+        margin: 2px;
+      }
+      .bim-legend .not_started {
+        background-color: #ff0000;
+      }
+      .bim-legend .in_progress {
+        background-color: #f39b3a;
+      }
+      .bim-legend .complete {
+        background-color: #71e03a;
+      }
+
+      .bim-details-card {
+        float: right;
+        width: 20%;
+        /* background:rgb(249, 247, 249); */
+        right: 1%;
+        top: 50%;
+        height: 25%;
+        position: absolute;
+        z-index: 2;
+        display: none;
+      }
+
+      table {
+        font-family: arial, sans-serif;
+        border-collapse: collapse;
+        width: 100%;
+      }
+
+      td,
+      th {
+        border: 1px solid #dddddd;
+        text-align: left;
+        padding: 8px;
+        background-color: #dddddd;
+      }
+
+      .bim-card-close {
+        right: 0px;
+        top: 0px;
+        z-index: 2;
+        position: absolute;
+      }
+
+      .bim-card-close:hover {
+        /* background: rgb(0, 217, 255); */
+        cursor: pointer;
+        /* opacity: 1; */
+      }
+    </style>
+  </head>
+
+  <body>
+    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
+    <script src="../libs/spectrum/spectrum.js"></script>
+    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
+    <script src="../libs/other/BinaryHeap.js"></script>
+    <script src="../libs/tween/tween.min.js"></script>
+    <script src="../libs/d3/d3.js"></script>
+    <script src="../libs/proj4/proj4.js"></script>
+    <script src="../libs/openlayers3/ol.js"></script>
+    <script src="../libs/i18next/i18next.js"></script>
+    <script src="../libs/jstree/jstree.js"></script>
+    <script src="../build/potree/potree.js"></script>
+    <script src="../libs/plasio/js/laslaz.js"></script>
+
+    <div
+      id="viewer_1"
+      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
+    >
+      <div id="fpContainer_1" class="floormap" onclick="actionIconClick()">
+        <i
+          title="fullscreen"
+          id="fp_fullscreen_1"
+          data='{"id": "viewer_1", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          >fullscreen</i
+        >
+        <i
+          title="minimise"
+          id="fp_minimise_1"
+          data='{"id": "viewer_1", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          style="display: none"
+          >fullscreen_exit</i
+        >
+        <canvas id="floormap_1"></canvas>
+      </div>
+      <div id="no_bim_1" class="noBIM">
+        <p>Data Not Available</p>
+      </div>
+      <div
+        id="bim_details_card_container_1"
+        class="bim-details-card"
+        onclick="actionIconClick()"
+      >
+        <i
+          data='{"id": "viewer_1", "type": "bim_card_close"}'
+          class="material-icons bim-card-close"
+          >clear</i
+        >
+        <div id="bim_details_card_1"></div>
+      </div>
+      <div
+        id="bim_legend_1"
+        class="bim-legend-container bim-legend"
+        onclick="actionIconClick()"
+      >
+        <li
+          id="bim_not_started"
+          data='{"id": "viewer_1", "type": "bim_legend"}'
+        >
+          <span class="not_started"></span> Not Started
+        </li>
+        <li
+          id="bim_in_progress"
+          data='{"id": "viewer_1", "type": "bim_legend"}'
+        >
+          <span class="in_progress"></span> In Progress
+        </li>
+        <li id="bim_complete" data='{"id": "viewer_1", "type": "bim_legend"}'>
+          <span class="complete"></span> Complete
+        </li>
+      </div>
+      <div
+        id="action_buttons_1"
+        onclick="actionIconClick()"
+        class="actionButtons"
+      >
+        <div class="dropup actionButtonsTest">
+          <input class="datepickerDigi" type="text" id="datepickerLeft" />
+        </div>
+        <div title="bim compare" class="dropup actionButtonsTest">
+          <img
+            id="bim_compare_view_1"
+            data='{"id": "viewer_1", "type":"bim-compare"}'
+            src="https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/3d-bim1.png"
+            class="s3-icon"
+          />
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="timeline compare"
+            id="compare_view_1"
+            data='{"id": "viewer_1", "type": "compare"}'
+            class="material-icons icon-test"
+            >compare</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="point cloud"
+            id="3d_view_1"
+            data='{"id": "viewer_1", "type": "3d"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >3d_rotation</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="show images"
+            id="cameras_on_1"
+            data='{"id": "viewer_1", "type": "cameras", "condition": "on"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >photo_camera</i
+          >
+          <i
+            title="hide images"
+            id="cameras_off_1"
+            data='{"id": "viewer_1", "type": "cameras", "condition": "off"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >no_photography</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            id="measure_top_1"
+            data='{"id": "viewer_1", "type": "measure"}'
+            title="measure"
+            data-toggle="dropdown"
+            class="material-icons icon-test"
+            >straighten</i
+          >
+          <ul id="measure_tool_1" class="dropdown-menu" style="margin: unset">
+            <i
+              title="point"
+              data='{"id": "viewer_1", "type": "point"}'
+              class="material-icons icon-test"
+              >gps_fixed</i
+            >
+            <i
+              title="distance"
+              data='{"id": "viewer_1", "type": "distance"}'
+              class="material-icons icon-test"
+              >timeline</i
+            >
+            <i
+              title="area"
+              data='{"id": "viewer_1", "type": "area"}'
+              class="material-icons icon-test"
+              >crop</i
+            >
+            <i
+              title="height"
+              data='{"id": "viewer_1", "type": "height"}'
+              class="material-icons icon-test"
+              >height</i
+            >
+            <i
+              title="clear"
+              data='{"id": "viewer_1", "type": "clear"}'
+              class="material-icons icon-test"
+              >clear</i
+            >
+            <i
+              title="save"
+              data='{"id": "viewer_1", "type": "save"}'
+              class="material-icons icon-test"
+              >save</i
+            >
+          </ul>
+        </div>
+      </div>
+    </div>
+    <div
+      id="viewer_2"
+      style="
+        position: absolute;
+        width: 50%;
+        height: 100%;
+        right: 0px;
+        top: 0px;
+        display: none;
+      "
+    >
+      <div id="fpContainer_2" class="floormap" onclick="actionIconClick()">
+        <i
+          title="fullscreen"
+          id="fp_fullscreen_2"
+          data='{"id": "viewer_2", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          >fullscreen</i
+        >
+        <i
+          title="minimise"
+          id="fp_minimise_2"
+          data='{"id": "viewer_2", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          style="display: none"
+          >fullscreen_exit</i
+        >
+        <canvas id="floormap_2"></canvas>
+      </div>
+      <div id="no_bim_2" class="noBIM">
+        <p>Data Not Available</p>
+      </div>
+
+      <div
+        id="bim_details_card_container_2"
+        class="bim-details-card"
+        onclick="actionIconClick()"
+      >
+        <i
+          data='{"id": "viewer_2", "type": "bim_card_close"}'
+          class="material-icons bim-card-close"
+          >clear</i
+        >
+        <div id="bim_details_card_2"></div>
+      </div>
+
+      <div
+        id="bim_legend_2"
+        class="bim-legend-container bim-legend"
+        onclick="actionIconClick()"
+      >
+        <li
+          title="not srated"
+          id="bim_not_started"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="not_started"></span> Not Started
+        </li>
+        <li
+          title="in progress"
+          id="bim_in_progress"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="in_progress"></span> In Progress
+        </li>
+        <li
+          title="completed"
+          id="bim_complete"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="complete"></span> Complete
+        </li>
+      </div>
+      <div
+        id="action_buttons_2"
+        onclick="actionIconClick()"
+        class="actionButtons"
+      >
+        <div class="dropup actionButtonsTest">
+          <input class="datepickerDigi" type="text" id="datepickerRight" />
+        </div>
+        <div title="bim compare" class="dropup actionButtonsTest">
+          <img
+            id="bim_compare_view_2"
+            data='{"id": "viewer_2", "type" : "bim-compare"}'
+            src="https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/3d-bim1.png"
+            class="s3-icon"
+          />
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="timeline compare"
+            id="compare_view_2"
+            data='{"id": "viewer_2", "type": "3d"}'
+            class="material-icons icon-test"
+            >compare</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="point cloud"
+            id="3d_view_2"
+            data='{"id": "viewer_2", "type": "3d"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >3d_rotation</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            title="show images"
+            id="cameras_on_2"
+            data='{"id": "viewer_2", "type": "cameras", "condition": "on"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >photo_camera</i
+          >
+          <i
+            title="hide images"
+            id="cameras_off_2"
+            data='{"id": "viewer_2", "type": "cameras", "condition": "off"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >no_photography</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            id="measure_top_2"
+            data='{"id": "viewer_2", "type": "measure"}'
+            title="measure"
+            data-toggle="dropdown"
+            class="material-icons icon-test"
+            >straighten</i
+          >
+          <ul id="measure_tool_2" class="dropdown-menu" style="margin: unset">
+            <i
+              title="point"
+              data='{"id": "viewer_2", "type": "point"}'
+              class="material-icons icon-test"
+              >gps_fixed</i
+            >
+            <i
+              title="distance"
+              data='{"id": "viewer_2", "type": "distance"}'
+              class="material-icons icon-test"
+              >timeline</i
+            >
+            <i
+              title="area"
+              data='{"id": "viewer_2", "type": "area"}'
+              class="material-icons icon-test"
+              >crop</i
+            >
+            <i
+              title="height"
+              data='{"id": "viewer_2", "type": "height"}'
+              class="material-icons icon-test"
+              >height</i
+            >
+            <i
+              title="clear"
+              data='{"id": "viewer_2", "type": "clear"}'
+              class="material-icons icon-test"
+              >clear</i
+            >
+            <i
+              title="save"
+              data='{"id": "viewer_2", "type": "save"}'
+              class="material-icons icon-test"
+              >save</i
+            >
+          </ul>
+        </div>
+      </div>
+      <div class="closeBtn actionButtonsTest" onclick="actionIconClick()">
+        <i
+          title="close compare"
+          data='{"id": "viewer_2", "type": "compare-close"}'
+          class="material-icons icon-test"
+          >clear</i
+        >
+      </div>
+    </div>
+
+    <script type="module">
+      // http://localhost:4200/examples/tourWrapperAdv.html?project=16&snapshot1=12&snapshot2=11&isExterior=0&isFM=1&mode=compare_bim
+      // http://localhost:4200/examples/tourWrapperAdv.html?project=25&snapshot1=16&snapshot2=17&isExterior=1&isFM=0&mode=compare_bim
+
+      function getParameterByName(name, url = window.location.href) {
+        name = name.replace(/[\[\]]/g, "\\$&");
+        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
+          results = regex.exec(url);
+        if (!results) return null;
+        if (!results[2]) return "";
+        return decodeURIComponent(results[2].replace(/\+/g, " "));
+      }
+
+      function doAPIcall(in_url, in_method, in_token) {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: in_url,
+            method: in_method,
+            headers: {
+              authorization: "Bearer " + in_token,
+            },
+
+            success: (rawData) => {
+              console.log(rawData);
+              resolve(rawData);
+            },
+            error: (e) => {
+              console.log(e);
+              resolve(null);
+            },
+          });
+        });
+      }
+      const mainProjectID = getParameterByName("project");
+      const structure_id = getParameterByName("structure");
+      const inTilesetID = getParameterByName("snapshot1");
+      const inTilesetID2 = getParameterByName("snapshot2");
+      // const isExterior = parseInt(getParameterByName('isExterior'));
+      // const isFloorMap = parseInt(getParameterByName('isFM'));
+      const mode = getParameterByName("mode");
+      const token = getParameterByName("token"); //'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiJVU1IzOTA4OTUiLCJmaXJzdE5hbWUiOiJLcmlzaG5hIFRlamEiLCJsYXN0TmFtZSI6IlRhbmdhdHVyaSIsImVtYWlsIjoia3RkYWlpY3RAZ21haWwuY29tIiwiY29udGFjdCI6eyJjb2RlIjoiKzkxIiwibnVtYmVyIjo5Njc2MzE2MzIzfSwiZG9iIjoiMTk4OS0wMi0xNlQwMDowMDowMC4wMDBaIiwidmVyaWZpZWQiOnRydWUsImNyZWF0ZWRBdCI6IjIwMjItMDMtMjJUMTI6MTY6MzAuODk0WiIsInVwZGF0ZWRBdCI6IjIwMjItMDMtMjJUMTI6MTc6NTMuMTIyWiIsIl9fdiI6MCwiZnVsbE5hbWUiOiJLcmlzaG5hIFRlamEgVGFuZ2F0dXJpIiwiYWdlIjozMywiaWF0IjoxNjUxNzY4MDExLCJleHAiOjE2NTE3NzE2MTF9.xJT4oa55tODe7KzK7YkYM62NrpgJfWzusbevVggL_Vg'
+      // const structure_id = 'STR772693' //getParameterByName('structure');
+      const inProjectID = structure_id;
+      const structure_id_details = await doAPIcall(
+        "https://api.dev.constructn.ai/api/v1/projects/" +
+          mainProjectID +
+          "/structures/" +
+          structure_id,
+        "GET",
+        token
+      );
+      console.log(
+        "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
+      );
+      // console.log(structure_id_details)
+
+      const isExterior = structure_id_details["result"]["isExterior"] ? 1 : 0;
+
+      const isFloorMap = structure_id_details["result"]["isExterior"] ? 0 : 1;
+
+      console.log("Exterior : ", isExterior);
+
+      const inputCamera = JSON.parse(getParameterByName("camera"));
+      console.log("Input Camera ", inputCamera);
+
+      const inputTag = JSON.parse(getParameterByName("tag"));
+      console.log("Input Tag", inputTag);
+
+      let isCompareMode = false;
+      let isMouseOnV1 = true;
+      let compareType = "potree";
+      let viewerMode = "image";
+      let syncPotreeEvent = false;
+      let syncForgeEvent = false;
+      let bimProgressData = {};
+      let bimProgressMode = false;
+      var tagToAddOnImageLoad = null;
+      let progress_walk_index = 0;
+      let progress_walk_mode = false;
+
+      let s3_bucket = "constructn-projects"; //'digitrack-projects'
+
+      import * as THREE from "../libs/three.js/build/three.module.js";
+      // initFirstPotree();
+      // window.compareMode = compareMode;
+      // window.loadSnapshot = loadSnapshot;
+      // window.closeCompareMode = closeCompareMode;
+      // window.addMeasure = addMeasure;
+      // window.removeMeasure = removeMeasure;
+      window.actionIconClick = actionIconClick;
+      window.locate = locate;
+      window.getInverse = getInverse;
+      window.select_group_bim = select_group_bim;
+      window.bimDefaultView = bimDefaultView;
+      window.remove_group_bim = remove_group_bim;
+      window.addTag = addTag;
+      window.start_progress_delta_walk = start_progress_delta_walk;
+      window.exit_progress_walk = exit_progress_walk;
+      window.update_progress_walk = update_progress_walk;
+
+      if (mode == "3d") {
+        initFirstPotree();
+      } else if (mode == "compare_3d") {
+        initFirstPotree();
+        compareMode("potree");
+      } else if (mode == "compare_bim") {
+        initFirstPotree();
+        compareMode("forge");
+      } else if (mode == "bim") {
+        viewerMode = "3d";
+        initForge(inProjectID, inTilesetID, "viewer_1", inputCamera);
+        // document.getElementById('fpContainer_2').style.display = 'none';
+      }
+
+      window.addEventListener("message", function (e) {
+        console.log("From Parent : ", e.data);
+        if (e.data.type == "getCamera") {
+          let cam = locate(viewer_1);
+          console.log("Sending Camera Details to Parent : ", cam);
+          window.top.postMessage(
+            { type: "camera", data: JSON.stringify(cam) },
+            "*"
+          );
+        } else if (e.data.type == "context") {
+          flyToContext(e.data.data);
+        } else if (e.data.type == "select-tag") {
+          let tagData = JSON.parse(e.data.data);
+          console.log(tagData);
+          flyToTagContext(tagData);
+        } else if (e.data.type == "bim-grouping") {
+          let data = e.data.data;
+          if (viewer_1.customtype == "forge") {
+            select_group_bim(data.guids, viewer_1, data.mode, data.condition);
+          } else if (compareMode && viewer_2.customtype == "forge") {
+            select_group_bim(data.guids, viewer_2, data.mode, data.condition);
+          }
+        } else if (e.data.type == "reset-bim-grouping") {
+          if (viewer_1.customtype == "forge") {
+            remove_group_bim(viewer_1, e.data.data.mode);
+          } else if (compareMode && viewer_2.customtype == "forge") {
+            remove_group_bim(viewer_2, e.data.data.mode);
+          }
+        }
+      });
+
+      function initFirstPotree() {
+        if (inTilesetID == "") {
+          document.getElementById("no_bim_1").style.display = "block";
+        } else {
+          window.viewer_1 = new Potree.Viewer(
+            document.getElementById("viewer_1")
+          );
+          viewer_1.setFOV(60);
+          viewer_1.setPointBudget(1 * 1000 * 1000);
+          document.title = "";
+          viewer_1.setEDLEnabled(false);
+          viewer_1.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
+          viewer_1.setDescription(``);
+          viewer_1.loadSettingsFromURL();
+          viewer_1.canvasId = "viewer_1";
+          viewer_1.customtype = "potree";
+
+          viewer_1.loadGUI(async () => {
+            viewer_1.setLanguage("en");
+            console.log("VIewer_1 Loaded");
+            viewer_1.fpContainerId = "fpContainer_1";
+            viewer_1.fpCanvasId = "floormap_1";
+            loadSnapshot(
+              viewer_1,
+              inProjectID,
+              inTilesetID,
+              false,
+              inputCamera
+            );
+            viewer_1.tileset = inTilesetID;
+            toggleVisibility("action_buttons_1", true);
+            addEventListeners();
+          });
+        }
+      }
+
+      function addEventListeners() {
+        document
+          .getElementById("viewer_1")
+          .addEventListener("mouseenter", () => {
+            isMouseOnV1 = true;
+          });
+        document
+          .getElementById("viewer_2")
+          .addEventListener("mouseenter", () => {
+            isMouseOnV1 = false;
+          });
+
+        document.addEventListener("imageLoad", (event) => {
+          console.log("imageLoad ", event.detail.viewer, event.detail.image);
+          viewer_1.scene.removeAllMeasurements();
+          if (isCompareMode && compareType == "potree") {
+            viewer_2.scene.removeAllMeasurements();
+          }
+          viewerMode = "image";
+          toggleVisibility("3d_view_1", true);
+          toggleVisibility("3d_view_2", true);
+
+          if (event.detail.viewer == "viewer_1") {
+            viewer_1.cur_loaded_image = event.detail.image.id;
+          } else {
+            viewer_2.cur_loaded_image = event.detail.image.id;
+          }
+
+          if (isCompareMode) {
+            if (compareType == "forge") {
+              setForgeControls("image");
+            } else {
+              maintainContext(event.detail.viewer, event.detail.image);
+            }
+          }
+          pointCloudView(true);
+
+          setTimeout(() => {
+            if (tagToAddOnImageLoad != null) {
+              console.log("Adding Tag");
+              console.log(tagToAddOnImageLoad["info"]);
+              addTag(
+                tagToAddOnImageLoad["info"],
+                tagToAddOnImageLoad["viewer"]
+              );
+              tagToAddOnImageLoad = null;
+            }
+          }, 100);
+        });
+
+        document.addEventListener("imageUnload", (event) => {
+          console.log("imageUnload ", event.detail.viewer);
+          toggleVisibility("3d_view_1", false);
+          toggleVisibility("3d_view_2", false);
+          viewer_1.scene.removeAllClipVolumes(); // To remove hovered image
+          viewer_1.scene.removeAllMeasurements();
+          viewer_1.cur_loaded_image = null;
+          if (isCompareMode) {
+            viewerMode = "3d";
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.scene.removeAllMeasurements();
+            }
+            viewer_2.cur_loaded_image = null;
+            if (compareType == "forge") {
+              setForgeControls("orbit");
+            } else {
+              if (event.detail.viewer == "viewer_1") {
+                viewer_2.scene.orientedImages[0].release();
+              } else {
+                viewer_1.scene.orientedImages[0].release();
+              }
+              viewer_2.scene.removeAllClipVolumes(); // To remove hovered image
+            }
+            viewer_1.fitToScreen();
+            if (!isMouseOnV1) {
+              if (compareType == "potree") {
+                viewer_2.fitToScreen();
+              } else {
+                viewer_2.navigation.setRequestFitToView(true);
+              }
+            }
+            pointCloudView(false);
+          } else if (event.detail.viewer == "viewer_1") {
+            viewer_1.fitToScreen();
+            pointCloudView(false);
+            viewerMode = "3d";
+          }
+        });
+
+        let zoomHandler_1 = (e) => {
+          let fov_delta = e.wheelDelta < 0 ? -5 : 5;
+          let fov = viewer_1.getFOV() + fov_delta;
+          if (fov > 10 && fov < 100) {
+            viewer_1.setFOV(fov);
+          }
+          isCompareMode && syncViewers();
+        };
+
+        let zoomHandler_2 = (e) => {
+          let fov_delta = e.wheelDelta < 0 ? -5 : 5;
+          let fov = viewer_2.getFOV() + fov_delta;
+          if (fov > 10 && fov < 100) {
+            viewer_2.setFOV(fov);
+          }
+          isCompareMode && syncViewers();
+        };
+
+        document.addEventListener("panoLoad", (event) => {
+          console.log("panoLoad ", event.detail.viewer, event.detail.image);
+          viewerMode = "panorama";
+          viewer_1.renderArea.addEventListener("mousewheel", zoomHandler_1);
+          viewer_1.scene.removeAllMeasurements();
+          if (isCompareMode && compareType == "potree") {
+            viewer_2.renderArea.addEventListener("mousewheel", zoomHandler_2);
+            viewer_2.scene.removeAllMeasurements();
+          }
+          if (event.detail.viewer == "viewer_1") {
+            viewer_1.cur_loaded_image = event.detail.image.file
+              .split("/")
+              .pop();
+          } else {
+            viewer_2.cur_loaded_image = event.detail.image.file
+              .split("/")
+              .pop();
+          }
+          if (isCompareMode) {
+            if (compareType == "forge") {
+              setForgeControls("panorama");
+            } else {
+              maintainContext(event.detail.viewer, event.detail.image);
+            }
+          }
+          pointCloudView(true);
+
+          if (viewer_1.isFloorMap) {
+            toggleFloorMap(viewer_1, true);
+          }
+
+          if (isCompareMode && compareType == "potree" && viewer_2.isFloorMap) {
+            toggleFloorMap(viewer_2, true);
+          }
+
+          setTimeout(() => {
+            if (tagToAddOnImageLoad != null) {
+              console.log("Adding Tag");
+              console.log(tagToAddOnImageLoad["info"]);
+              addTag(
+                tagToAddOnImageLoad["info"],
+                tagToAddOnImageLoad["viewer"]
+              );
+              tagToAddOnImageLoad = null;
+            }
+          }, 100);
+        });
+
+        document.addEventListener("panoUnload", (event) => {
+          console.log("panoUnload ", event.detail.viewer);
+          viewer_1.cur_loaded_image = null;
+          viewer_1.scene.removeAllMeasurements();
+          viewer_1.renderArea.removeEventListener("mousewheel", zoomHandler_1);
+          if (isCompareMode) {
+            viewer_2.cur_loaded_image = null;
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.renderArea.removeEventListener(
+                "mousewheel",
+                zoomHandler_2
+              );
+              viewer_2.scene.removeAllMeasurements();
+            }
+            viewerMode = "3d";
+            if (compareType == "forge") {
+              setForgeControls("orbit");
+            } else {
+              if (event.detail.viewer == "viewer_1") {
+                viewer_2.scene.images360[0].unfocus();
+              } else {
+                viewer_1.scene.images360[0].unfocus();
+              }
+            }
+            viewer_1.fitToScreen();
+            if (!isMouseOnV1) {
+              if (compareType == "potree") {
+                viewer_2.fitToScreen();
+              } else {
+                viewer_2.navigation.setRequestFitToView(true);
+              }
+            }
+            pointCloudView(false);
+
+            if (viewer_1.isFloorMap) {
+              toggleFloorMap(viewer_1, false);
+            }
+
+            if (compareType == "potree" && viewer_2.isFloorMap) {
+              toggleFloorMap(viewer_2, false);
+            }
+          } else if (event.detail.viewer == "viewer_1") {
+            viewer_1.fitToScreen();
+            pointCloudView(false);
+            if (viewer_1.isFloorMap) {
+              toggleFloorMap(viewer_1, false);
+            }
+            viewerMode = "3d";
+          }
+        });
+
+        // Keyboard Shortcuts
+
+        document.addEventListener("keydown", (event) => {
+          if (event.key === "Escape") {
+            // Exit in viewer 2 is already handled in contex maintanance
+            if (viewerMode == "image") {
+              viewer_1.controls.elExit.click();
+            }
+            // else if (viewerMode == 'panorama') {
+            //     viewer_1.scene.images360[0].unfocus();
+            // }
+          } else if (event.key === "ArrowUp") {
+            // up arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elUp.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elUp.click();
+              }
+            } else if (viewerMode == "panorama") {
+              if (event.ctrlKey) {
+                setPitch(viewer_1, 0.5);
+                if (isCompareMode && compareType == "potree") {
+                  setPitch(viewer_2, 0.5);
+                }
+              } else {
+                nextPanoImage(viewer_1);
+              }
+            }
+          } else if (event.key === "ArrowDown") {
+            // down arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elDown.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elDown.click();
+              }
+            } else if (viewerMode == "panorama") {
+              if (event.ctrlKey) {
+                setPitch(viewer_1, -0.5);
+                if (isCompareMode && compareType == "potree") {
+                  setPitch(viewer_2, -0.5);
+                }
+              }
+            }
+          } else if (event.key === "ArrowLeft") {
+            // left arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elLeft.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elLeft.click();
+              }
+            } else if (viewerMode == "panorama") {
+              setYaw(viewer_1, 0.5);
+              if (isCompareMode && compareType == "potree") {
+                setYaw(viewer_2, 0.5);
+              }
+            }
+          } else if (event.key === "ArrowRight") {
+            // right arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elRight.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elRight.click();
+              }
+            } else if (viewerMode == "panorama") {
+              setYaw(viewer_1, -0.5);
+              if (isCompareMode && compareType == "potree") {
+                setYaw(viewer_2, -0.5);
+              }
+            }
+          }
+        });
+
+        // document.addEventListener('mousedown', event => {
+        // 	sendSyncEvents = true;
+        // });
+        // document.addEventListener('mouseup', event => {
+        // 	sendSyncEvents = false;
+        // });
+
+        document.addEventListener("camerachange", (event) => {
+          syncPotreeEvent = true;
+        });
+      }
+
+      function pointCloudView(cond) {
+        viewer_1.setEDLEnabled(cond);
+        if (cond) {
+          viewer_1.setEDLOpacity(0);
+        } else {
+          viewer_1.setEDLOpacity(1);
+        }
+        if (isCompareMode && compareType == "potree") {
+          viewer_2.setEDLEnabled(cond);
+          if (cond) {
+            viewer_2.setEDLOpacity(0);
+          } else {
+            viewer_2.setEDLOpacity(1);
+          }
+        }
+      }
+
+      function maintainContext(viewerId, info) {
+        if (viewerMode == "image") {
+          let nearestImage = null;
+          let nearestImageDist = 10000;
+          if (viewerId == "viewer_1" && viewer_2.scene.orientedImages[0]) {
+            viewer_2.scene.orientedImages[0].images.forEach((image) => {
+              let curDist = image.position.distanceTo(info.position);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = image;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.id);
+              viewer_2.scene.orientedImages[0].moveToImage(nearestImage, false);
+              viewer_2.cur_loaded_image = nearestImage.id;
+            }
+          } else if (viewer_1.scene.orientedImages[0]) {
+            viewer_1.scene.orientedImages[0].images.forEach((image) => {
+              let curDist = image.position.distanceTo(info.position);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = image;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.id);
+              viewer_1.scene.orientedImages[0].moveToImage(nearestImage, false);
+              viewer_1.cur_loaded_image = nearestImage.id;
+            }
+          }
+        } else {
+          let nearestImage = null;
+          let nearestImageDist = 1000;
+          let inputPos = new THREE.Vector2().fromArray([
+            info.position[0],
+            info.position[1],
+          ]);
+          if (viewerId == "viewer_1") {
+            if (viewer_2.scene.images360[0]) {
+              viewer_2.scene.images360[0].images.forEach((pano) => {
+                let curPos = new THREE.Vector2().fromArray([
+                  pano.position[0],
+                  pano.position[1],
+                ]);
+                let curDist = curPos.distanceTo(inputPos);
+                if (curDist < nearestImageDist) {
+                  nearestImageDist = curDist;
+                  nearestImage = pano;
+                }
+              });
+              if (nearestImage) {
+                console.log(nearestImage.file);
+                viewer_2.scene.images360[0].focus(nearestImage, false);
+                viewer_2.cur_loaded_image = nearestImage.file.split("/").pop();
+              }
+            }
+          } else if (viewer_1.scene.images360[0]) {
+            viewer_1.scene.images360[0].images.forEach((pano) => {
+              let curPos = new THREE.Vector2().fromArray([
+                pano.position[0],
+                pano.position[1],
+              ]);
+              let curDist = curPos.distanceTo(inputPos);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = pano;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.file);
+              viewer_1.scene.images360[0].focus(nearestImage, false);
+              viewer_1.cur_loaded_image = nearestImage.file.split("/").pop();
+            }
+          }
+        }
+      }
+
+      function getNearestImage(viewer, camInfo, mode) {
+        let nearestImage = null;
+        let nearestImageDist = 10000;
+        if (mode == "image") {
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            let curDist = image.position.distanceTo(camInfo.position);
+            if (curDist < nearestImageDist) {
+              nearestImageDist = curDist;
+              nearestImage = image;
+            }
+          });
+          if (nearestImage) {
+            console.log(nearestImage.id);
+            viewer.scene.orientedImages[0].moveToImage(nearestImage);
+          }
+        } else {
+          let inputPos = new THREE.Vector2().fromArray([
+            camInfo.position.x,
+            camInfo.position.y,
+          ]);
+          viewer.scene.images360[0].images.forEach((pano) => {
+            let curPos = new THREE.Vector2().fromArray([
+              pano.position[0],
+              pano.position[1],
+            ]);
+            let curDist = curPos.distanceTo(inputPos);
+            if (curDist < nearestImageDist) {
+              nearestImageDist = curDist;
+              nearestImage = pano;
+            }
+          });
+          if (nearestImage) {
+            console.log(nearestImage.file);
+            viewer.scene.images360[0].focus(nearestImage, true, camInfo);
+          }
+        }
+      }
+
+      function syncViewers() {
+        if (isCompareMode) {
+          if (viewerMode == "3d") {
+            if (isMouseOnV1) {
+              if (compareType == "potree") {
+                let v1Pos = viewer_1.scene.view.position.toArray();
+                viewer_2.scene.view.position.set(v1Pos[0], v1Pos[1], v1Pos[2]);
+                viewer_2.scene.view.lookAt(viewer_1.scene.view.getPivot());
+                viewer_2.setFOV(viewer_1.fov);
+              } else if (syncPotreeEvent) {
+                // Conditional syncing only for forge
+                viewer_2.navigation.setPosition(
+                  viewer_1.scene.view.position.clone()
+                );
+                viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+                viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+              }
+            } else {
+              if (compareType == "potree") {
+                let v2Pos = viewer_2.scene.view.position.toArray();
+                viewer_1.scene.view.position.set(v2Pos[0], v2Pos[1], v2Pos[2]);
+                viewer_1.scene.view.lookAt(viewer_2.scene.view.getPivot());
+                viewer_1.setFOV(viewer_2.fov);
+              } else if (syncForgeEvent) {
+                viewer_2.navigation.setCameraUpVector(
+                  new THREE.Vector3().fromArray([0, 0, 1])
+                );
+                const state = viewer_2.getState({ viewport: true }).viewport;
+                viewer_1.scene.view.position.set(
+                  state.eye[0],
+                  state.eye[1],
+                  state.eye[2]
+                );
+                viewer_1.scene.view.lookAt(
+                  new THREE.Vector3().fromArray(state.target)
+                );
+                viewer_1.setFOV(state.fieldOfView);
+                // viewer_2.navigation.setWorldUpVector(new THREE.Vector3().fromArray([0, 0, 1]), false);
+              }
+            }
+          } else if (viewerMode == "panorama" && compareType == "potree") {
+            if (isMouseOnV1) {
+              viewer_2.scene.view.pitch = viewer_1.scene.view.pitch;
+              viewer_2.scene.view.yaw = viewer_1.scene.view.yaw;
+              viewer_2.fov = viewer_1.fov;
+            } else {
+              viewer_1.scene.view.pitch = viewer_2.scene.view.pitch;
+              viewer_1.scene.view.yaw = viewer_2.scene.view.yaw;
+              viewer_1.fov = viewer_2.fov;
+            }
+          } else if (compareType == "forge" && syncPotreeEvent) {
+            // Do nothing if secondary viewer is potree
+            viewer_2.navigation.setPosition(
+              viewer_1.scene.view.position.clone()
+            );
+            viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+            viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+          }
+          syncPotreeEvent = false;
+          syncForgeEvent = false;
+        }
+      }
+
+      async function loadPointCloud(
+        viewer,
+        projectID,
+        tilesetID,
+        secondary = false,
+        inCamera
+      ) {
+        let pcMatrix = new THREE.Matrix4().set(
+          1,
+          0,
+          0,
+          0,
+          0,
+          1,
+          0,
+          0,
+          0,
+          0,
+          1,
+          0,
+          0,
+          0,
+          0,
+          1
+        );
+        let pcOffset = [0, 0, 0];
+        viewer["globalOffset"] = pcOffset;
+        const tm_json_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/pointcloud/tm.json`
+        );
+        if (tm_json_raw.status == 200) {
+          const tm_json = JSON.parse(await tm_json_raw.text());
+          if (tm_json.tm) {
+            pcMatrix = new THREE.Matrix4().fromArray(tm_json.tm).transpose();
+          }
+          if (tm_json.offset) {
+            pcOffset = tm_json.offset;
+          }
+          viewer["globalOffset"] = pcOffset;
+          if (inCamera) {
+            let pos = inCamera.position;
+            let tar = inCamera.target;
+            let offset = viewer.globalOffset;
+            inCamera.position = new THREE.Vector3(
+              pos[0] - offset[0],
+              pos[1] - offset[1],
+              pos[2] - offset[2]
+            );
+            inCamera.target = new THREE.Vector3(
+              tar[0] - offset[0],
+              tar[1] - offset[1],
+              tar[2] - offset[2]
+            );
+          }
+          console.log("PC TM Loaded", tm_json);
+        }
+
+        Potree.loadPointCloud(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/pointcloud/cloud.json`,
+          projectID + "_" + tilesetID,
+          (e) => {
+            let scene = viewer.scene;
+            let pointcloud = e.pointcloud;
+
+            let material = pointcloud.material;
+            material.size = 1;
+            material.pointSizeType = Potree.PointSizeType.FIXED;
+            material.shape = Potree.PointShape.SQUARE;
+            pointcloud.applyMatrix(pcMatrix);
+            const assetPosition = pointcloud.position.clone();
+            pointcloud.position.set(
+              assetPosition.x - pcOffset[0],
+              assetPosition.y - pcOffset[1],
+              assetPosition.z - pcOffset[2]
+            );
+            scene.addPointCloud(pointcloud);
+            viewer.fitToScreen();
+            console.log("Point Cloud Loaded");
+
+            let startWithImage = true;
+
+            if (inputTag && !inputTag.image) {
+              let startWithImage = false;
+              viewerMode = "3d";
+              flyToContext(inputTag.camera);
+            }
+
+            if (isExterior) {
+              console.log("Exterior Project");
+              loadDroneImages(
+                viewer,
+                projectID,
+                tilesetID,
+                { tm: pcMatrix, offset: pcOffset },
+                secondary,
+                inCamera,
+                startWithImage
+              );
+              if (viewer.canvasId == "viewer_1") {
+                document.getElementById("cameras_off_1").style.display =
+                  "inline-block";
+              } else {
+                document.getElementById("cameras_off_2").style.display =
+                  "inline-block";
+              }
+            } else {
+              console.log("Interior Project");
+              // loadPanoImages(viewer, projectID, tilesetID, {tm: pcMatrix, offset1: [232067.2387, 1936749.6433, 563], offset: pcOffset}, secondary);
+              loadPanoImages(
+                viewer,
+                projectID,
+                tilesetID,
+                { tm: new THREE.Matrix4(), offset: pcOffset },
+                secondary,
+                inCamera,
+                startWithImage
+              );
+            }
+          }
+        );
+      }
+
+      function loadDroneImages(
+        viewer,
+        projectID,
+        tilesetID,
+        tmatrix,
+        secondary,
+        inCamera,
+        showImage
+      ) {
+        const imageParamsPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images.json`;
+        const imagesPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images`;
+        Potree.OrientedImageLoader.load(
+          imageParamsPath,
+          imagesPath,
+          viewer,
+          tmatrix
+        ).then((images) => {
+          viewer.scene.addOrientedImages(images);
+          // setTimeout(() => {
+          if (showImage) {
+            if (secondary && viewerMode == "image") {
+              maintainContext(
+                "viewer_1",
+                viewer_1.scene.orientedImages[0].focused
+              );
+              pointCloudView(true);
+            } else if (!secondary) {
+              // setTimeout(() => {
+              if (inputTag) {
+                flyToTagContext(inputTag);
+              } else if (inCamera) {
+                if (Array.isArray(inCamera.position)) {
+                  inCamera.position = new THREE.Vector3().fromArray(
+                    inCamera.position
+                  );
+                  inCamera.target = new THREE.Vector3().fromArray(
+                    inCamera.target
+                  );
+                }
+                getNearestImage(viewer, inCamera, "image");
+              } else {
+                viewer.scene.orientedImages[0].moveToImage(
+                  viewer.scene.orientedImages[0].images[0]
+                );
+              }
+              // }, 2000);
+            }
+          }
+          // }, 2000);
+        });
+      }
+
+      function loadPanoImages(
+        viewer,
+        projectID,
+        tilesetID,
+        tmatrix,
+        secondary,
+        inCamera,
+        showImage
+      ) {
+        viewerMode = "panorama";
+        const imageParamsPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images.json`;
+        // const imageParamsPath = `http://localhost:1234/indoor_images_15_17_48_66.json`;
+        // const imagesPath = `https://localhost:1234`
+        const imagesPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images`;
+        Potree.Images360Loader.load(
+          imageParamsPath,
+          imagesPath,
+          viewer,
+          tmatrix
+        ).then((images) => {
+          viewer.scene.add360Images(images);
+          if (showImage) {
+            if (secondary && viewerMode == "panorama") {
+              maintainContext(
+                "viewer_1",
+                viewer_1.scene.images360[0].focusedImage
+              );
+              // pointCloudView(true);viewer_2.navigation.setCameraUpVector(new THREE.Vector3().fromArray([0, 0, 1]));
+            } else if (!secondary) {
+              if (inputTag) {
+                flyToTagContext(inputTag);
+              } else if (inCamera) {
+                getNearestImage(viewer, inCamera, "panorama");
+              } else {
+                viewer.scene.images360[0].focus(
+                  viewer.scene.images360[0].images[0]
+                );
+              }
+            }
+          }
+        });
+      }
+
+      function compareMode(type) {
+        let pid = inProjectID;
+        let tid = inTilesetID2;
+        if (isCompareMode) {
+          closeCompareMode();
+        }
+        compareType = type;
+        document.getElementById("viewer_1").style.width = "50%";
+        document.getElementById("viewer_2").style.display = "block";
+
+        isCompareMode = true;
+        if (type == "potree") {
+          initSecondPotree(pid, tid);
+        } else {
+          initForge(pid, inTilesetID, "viewer_2");
+          document.getElementById("fpContainer_2").style.display = "none";
+        }
+
+        if (viewer_1.isFloorMap) {
+          updateFPSize(viewer_1.floorMap);
+        }
+      }
+
+      function closeCompareMode() {
+        isCompareMode = false;
+        document.getElementById("viewer_1").style.width = "100%";
+        document.getElementById("viewer_2").style.display = "none";
+        if (compareType == "forge") {
+          viewer_2.finish();
+          viewer_2 = null;
+          Autodesk.Viewing.shutdown();
+        } else {
+          removeAssets(viewer_2);
+          viewer_2 = null;
+        }
+
+        if (viewer_1.isFloorMap) {
+          updateFPSize(viewer_1.floorMap);
+        }
+      }
+
+      function initSecondPotree(pid_2, tid_2) {
+        if (tid_2 == "") {
+          document.getElementById("no_bim_2").style.display = "block";
+          isCompareMode = false;
+        } else {
+          window.viewer_2 = new Potree.Viewer(
+            document.getElementById("viewer_2")
+          );
+          viewer_2.setFOV(60);
+          viewer_2.setPointBudget(1 * 1000 * 1000);
+          document.title = "";
+          viewer_2.setEDLEnabled(false);
+          viewer_2.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
+          viewer_2.setDescription(``);
+          viewer_2.loadSettingsFromURL();
+          viewer_2.canvasId = "viewer_2";
+          viewer_2.customtype = "potree";
+
+          viewer_2.loadGUI(async () => {
+            viewer_2.setLanguage("en");
+            console.log("Viewer_2 Loaded");
+            isCompareMode = true;
+            viewer_2.fpContainerId = "fpContainer_2";
+            viewer_2.fpCanvasId = "floormap_2";
+            loadSnapshot(viewer_2, pid_2, tid_2, true);
+            viewer_2.tileset = tid_2;
+            toggleVisibility("action_buttons_2", true);
+          });
+        }
+      }
+
+      function removeAssets(viewer) {
+        viewer.scene.scenePointCloud.remove(viewer.scene.pointclouds[0]);
+        viewer.scene.pointclouds = [];
+        if (viewer.scene.orientedImages.length) {
+          viewer.scene.orientedImages[0].release();
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            viewer.scene.scene.children[0].remove(image.mesh);
+            viewer.scene.scene.children[0].remove(image.line);
+          });
+          viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+          viewer.scene.removeOrientedImages(viewer.scene.orientedImages[0]);
+        }
+
+        if (viewer.scene.images360.length) {
+          viewer.scene.images360[0].unfocus(false);
+          viewer.scene.images360[0].images.forEach((image) => {
+            viewer.scene.scene.children[0].remove(image.mesh);
+          });
+          viewer.scene.scene.children[0].remove(
+            viewer.scene.images360[0].sphere
+          );
+          viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+          viewer.scene.remove360Images(viewer.scene.images360[0]);
+        }
+        if (viewer.isFloorMap) {
+          removeFloorMap(viewer);
+        }
+      }
+
+      function loadSnapshot(
+        viewer,
+        pid,
+        tid,
+        secondary = false,
+        inCamera = null
+      ) {
+        removeAssets(viewer);
+        loadPointCloud(viewer, pid, tid, secondary, inCamera);
+        isFloorMap &&
+          loadFloormap(
+            viewer.fpContainerId,
+            viewer.fpCanvasId,
+            viewer,
+            pid,
+            tid
+          );
+      }
+
+      function getAutodeskToken() {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: "https://developer.api.autodesk.com/authentication/v1/authenticate",
+            method: "POST",
+            headers: {
+              "Content-Type": "application/x-www-form-urlencoded",
+            },
+            data: {
+              client_id: "aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM",
+              // client_id: 'iXWYm3FVGMhLYLssAQAwdMGMq5HsAwNb',
+              client_secret: "mSqemcEE53l4THBJ",
+              // client_Secret: 'hPvkyDrWToKUG8c3',
+              grant_type: "client_credentials",
+              scope: "data:read",
+            },
+            success: (rawData) => {
+              resolve(rawData);
+            },
+            error: (e) => {
+              resolve(null);
+            },
+          });
+        });
+      }
+
+      function pointerToRaycasterForge(domElement, camera, pointer) {
+        const pointerVector = new THREE.Vector3();
+        const pointerDir = new THREE.Vector3();
+        const ray = new THREE.Raycaster();
+        const rect = domElement.getBoundingClientRect();
+        const x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
+        const y = -((pointer.clientY - rect.top) / rect.height) * 2 + 1;
+        if (camera.isPerspective) {
+          pointerVector.set(x, y, 0.5);
+          pointerVector.unproject(camera);
+          ray.set(
+            camera.position,
+            pointerVector.sub(camera.position).normalize()
+          );
+        } else {
+          pointerVector.set(x, y, -1);
+          pointerVector.unproject(camera);
+          pointerDir.set(0, 0, -1);
+          ray.set(
+            pointerVector,
+            pointerDir.transformDirection(camera.matrixWorld)
+          );
+        }
+        return ray;
+      }
+
+      function getAllDbIds(viewer) {
+        const { instanceTree } = viewer.model.getData();
+        const { dbIdToIndex } = instanceTree.nodeAccess;
+        return Object.keys(dbIdToIndex).map((dbId) => {
+          return parseInt(dbId);
+        });
+      }
+
+      function initForge(pid, tid, divId, inCamera = null) {
+        var options = {
+          env: "Local",
+          api: "derivativeV2", // for models uploaded to EMEA change this option to 'derivativeV2_EU'
+          getAccessToken: async function (onTokenReady) {
+            const res = await getAutodeskToken();
+            onTokenReady(res.access_token, res.expires_in);
+          },
+        };
+        Autodesk.Viewing.Initializer(options, function () {
+          var htmlDiv = document.getElementById(divId);
+
+          const config3d = {
+            extensions: ["Autodesk.ADN.Viewing.Extension.Color"],
+          };
+
+          if (
+            inProjectID == "161" ||
+            inProjectID == "165" ||
+            inProjectID == "166"
+          ) {
+            config3d["navToolsConfig"] = {
+              dollyScrollScale: 0.005,
+            };
+          } else if (inProjectID == "235") {
+            config3d["navToolsConfig"] = {
+              dollyScrollScale: 0.001,
+            };
+          }
+
+          let viewer = new Autodesk.Viewing.GuiViewer3D(htmlDiv, config3d);
+          window[divId] = viewer;
+          var startedCode = viewer.start();
+          viewer.canvasId = divId;
+          if (startedCode > 0) {
+            console.error("Failed to create a Viewer: WebGL not supported.");
+            return;
+          }
+          console.log("Initialization complete, loading a model next...");
+          // isCompareMode = true;
+
+          viewer.navigation.setWorldUpVector(
+            new THREE.Vector3().fromArray([0, 0, 1]),
+            false
+          );
+
+          viewer.navigation.setReverseZoomDirection(true);
+
+          localStorage.setItem(
+            "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.viewCube",
+            false
+          );
+          localStorage.setItem(
+            "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.groundShadow",
+            false
+          );
+
+          viewer.addEventListener(
+            Autodesk.Viewing.CAMERA_CHANGE_EVENT,
+            (event) => {
+              syncForgeEvent = true;
+            }
+          );
+
+          viewer.container.addEventListener("click", function (ev) {
+            const result = viewer.clientToWorld(ev.clientX, ev.clientY);
+            if (result) {
+              console.log("Click Point", result.point);
+            }
+          });
+
+          viewer.addEventListener(
+            Autodesk.Viewing.SELECTION_CHANGED_EVENT,
+            (event) => {
+              var currSelection = viewer.getSelection();
+              console.log("Selection: ");
+
+              if (currSelection.length && bimProgressData[viewer.canvasId]) {
+                let guid =
+                  bimProgressData[viewer.canvasId]["dbtoguid"][
+                    currSelection[0]
+                  ];
+                let progress =
+                  bimProgressData[viewer.canvasId]["progress"][guid];
+
+                console.log(
+                  "dbid: ",
+                  currSelection[0],
+                  "guid: ",
+                  guid,
+                  "progress: ",
+                  progress
+                );
+
+                // let card_container_id = divId == 'viewer_1' ? 'bim_details_card_container_1' : 'bim_details_card_container_2'
+                // let card_id = divId == 'viewer_1' ? 'bim_details_card_1' : 'bim_details_card_2'
+                // let card_container = document.getElementById(card_container_id);
+                // let card = document.getElementById(card_id);
+                // let card_details = '<table>'
+                // card_details += `<tr> <td>    </td> <td>    </td> </tr>`
+                // card_details += `<tr> <td> GUID </td> <td> ${guid} </td> </tr>`
+                // card_details += `<tr> <td> Progress </td> <td> ${progress} </td> </tr>`
+
+                // card_details += '</table>'
+                // card.innerHTML = card_details;
+                // card_container.style.display = 'block';
+                let bim_element_details = { guid: guid, progress: progress };
+                window.top.postMessage(
+                  {
+                    type: "bim-click",
+                    data: JSON.stringify(bim_element_details),
+                  },
+                  "*"
+                );
+                console.log("Sending ", bim_element_details);
+
+                // const pointer = event.pointers ? event.pointers[0] : event;
+                // const rayCaster = pointerToRaycasterForge(viewer.canvas, viewer.navigation.getCamera(), pointer);
+                // const forgeClickObject = viewer.model.rayIntersect(rayCaster, true, this.getAllDbIds(viewer));
+                // console.log('Click point')
+                // console.log(forgeClickObject)
+
+                // const result = viewer.clientToWorld(event.clientX, event.clientY);
+                // if (result) {
+                // 	console.log(result.point);
+                // }
+              } else {
+                window.top.postMessage(
+                  { type: "bim-click", data: JSON.stringify({}) },
+                  "*"
+                );
+                // closeBimDetailsCard(divId);
+              }
+            }
+          );
+
+          viewer.customtype = "forge";
+          loadBIM(viewer, pid, tid, inCamera);
+        });
+      }
+
+      function closeBimDetailsCard(viewer_id) {
+        let container_id =
+          viewer_id == "viewer_1"
+            ? "bim_details_card_container_1"
+            : "bim_details_card_container_2";
+        let card = document.getElementById(container_id);
+        card.style.display = "none";
+        viewer_id == "viewer_1"
+          ? viewer_1.clearSelection()
+          : viewer_2.clearSelection();
+      }
+
+      async function loadBIM(viewer, pid, tid, inCamera) {
+        // let path = `http://localhost:1234/0.svf`;
+        let path = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/forge/model/0.svf`;
+        const modelOptions = { applyScaling: "m" };
+        modelOptions.globalOffset = { x: 0, y: 0, z: 0 };
+        let globalOff = [0, 0, 0];
+        viewer["globalOffset"] = globalOff;
+        viewer["properties_child"] = ["GLOBALID", "NAME"];
+        viewer["properties_head"] = ["IFC"];
+
+        const tm_json_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/forge/tm_forge.json`
+        );
+        if (tm_json_raw.status == 200) {
+          const tm_json = JSON.parse(await tm_json_raw.text());
+          if (tm_json.tm) {
+            modelOptions.placementTransform = new THREE.Matrix4()
+              .fromArray(tm_json.tm)
+              .transpose();
+            // modelOptions.placementTransform = new THREE.Matrix4().fromArray([0.216,1.022,-0.007,367033.477,-1.022,0.216,-0.001,2053135.281,-0.000,0.007,1.045,-57.5,0.000,0.000,0.000,1.000]).transpose()
+            console.log("BIM TM Loaded");
+          }
+
+          if (tm_json.offset) {
+            globalOff = tm_json.offset;
+            modelOptions.globalOffset = {
+              x: globalOff[0],
+              y: globalOff[1],
+              z: globalOff[2],
+            };
+          }
+
+          if (tm_json.properties_child) {
+            viewer["properties_child"] = tm_json.properties_child;
+          }
+
+          if (tm_json.properties_head) {
+            viewer["properties_head"] = tm_json.properties_head;
+          }
+
+          viewer["globalOffset"] = globalOff;
+          if (inCamera) {
+            let pos = inCamera.position;
+            let tar = inCamera.target;
+            let offset = viewer.globalOffset;
+            inCamera.position = new THREE.Vector3(
+              pos[0] - offset[0],
+              pos[1] - offset[1],
+              pos[2] - offset[2]
+            );
+            inCamera.target = new THREE.Vector3(
+              tar[0] - offset[0],
+              tar[1] - offset[1],
+              tar[2] - offset[2]
+            );
+          }
+        }
+
+        viewer.loadModel(
+          path,
+          modelOptions,
+          async (model) => {
+            if (inCamera) {
+              // Only Happens in 'bim' only mode
+              viewer.navigation.setPosition(inCamera.position);
+              viewer.navigation.setTarget(inCamera.target);
+            } else if (viewer.canvasId == "viewer_2") {
+              if (viewerMode != "3d") {
+                function checkFlag() {
+                  if (!viewer.getExtension("Autodesk.BimWalk")) {
+                    console.log("Loading BimWalk Extension ...");
+                    window.setTimeout(checkFlag, 1000);
+                  } else {
+                    setForgeControls(viewerMode);
+                  }
+                }
+                checkFlag();
+              }
+              viewer_2.navigation.setPosition(
+                viewer_1.scene.view.position.clone()
+              );
+              viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+              viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+            }
+
+            // Set Pivot Point
+
+            let fuzzy_box = viewer.model.getFuzzyBox();
+            let fuzzy_min = fuzzy_box["min"];
+            let fuzzy_max = fuzzy_box["max"];
+            let fuzzy_center = new THREE.Vector3(
+              (fuzzy_min["x"] + fuzzy_max["x"]) / 2,
+              (fuzzy_min["y"] + fuzzy_max["y"]) / 2,
+              (fuzzy_min["z"] + fuzzy_max["z"]) / 2
+            );
+            viewer.navigation.setPivotPoint(fuzzy_center);
+
+            // Generate GUID - DBID Mapping and progress view/
+
+            loadProgressView(viewer, pid, tid);
+          },
+          (e) => {
+            if (viewer.canvasId == "viewer_2") {
+              document.getElementById("no_bim_2").style.display = "block";
+            } else {
+              document.getElementById("no_bim_1").style.display = "block";
+            }
+          }
+        );
+      }
+
+      function loop(timestamp) {
+        syncViewers();
+        requestAnimationFrame(loop);
+        if (viewer_1.isFloorMap) {
+          updateUserLocation(viewer_1);
+        }
+        if (isCompareMode && compareType == "potree" && viewer_2.isFloorMap) {
+          updateUserLocation(viewer_2);
+        }
+      }
+
+      function setForgeControls(type) {
+        if (type == "orbit") {
+          viewer_2.navigation.setIsLocked(false);
+          if (viewer_2.getExtension("Autodesk.BimWalk")) {
+            viewer_2.getExtension("Autodesk.BimWalk").deactivate();
+          }
+        } else {
+          viewer_2.navigation.setLockSettings({
+            orbit: false,
+            pan: false,
+            zoom: false,
+            roll: false,
+            fov: true,
+          });
+          viewer_2.navigation.setIsLocked(true);
+
+          if (viewer_2.getExtension("Autodesk.BimWalk")) {
+            viewer_2.getExtension("Autodesk.BimWalk").activate();
+          }
+        }
+      }
+
+      function setPitch(viewer, delta) {
+        const startPitch = { p: viewer.scene.view.pitch };
+        const endPitch = { p: startPitch.p + delta };
+        let tween = new TWEEN.Tween(startPitch).to(endPitch, 500);
+        tween.easing(TWEEN.Easing.Quartic.Out);
+        tween.onUpdate(() => {
+          viewer.scene.view.pitch = startPitch.p;
+          syncPotreeEvent = true;
+        });
+        tween.onComplete(() => {
+          viewer.scene.view.pitch = endPitch.p;
+          syncPotreeEvent = true;
+        });
+        tween.start();
+      }
+
+      function setYaw(viewer, delta) {
+        const startYaw = { y: viewer.scene.view.yaw };
+        const endYaw = { y: startYaw.y + delta };
+        let tween = new TWEEN.Tween(startYaw).to(endYaw, 500);
+        tween.easing(TWEEN.Easing.Quartic.Out);
+        tween.onUpdate(() => {
+          viewer.scene.view.yaw = startYaw.y;
+          syncPotreeEvent = true;
+        });
+        tween.onComplete(() => {
+          viewer.scene.view.yaw = endYaw.y;
+          syncPotreeEvent = true;
+        });
+        tween.start();
+      }
+
+      function nextPanoImage(viewer) {
+        let cameraInstance = viewer.scene.cameraP;
+        const camDir = new THREE.Vector3();
+        cameraInstance.getWorldDirection(camDir);
+        camDir.normalize();
+        const camPos = cameraInstance.position;
+        const weightages = { angle: 0.5, distance: 0.5 };
+        let totalSum = 10000;
+        let curSum;
+        let selectedPanoImageId;
+        let cameraViewProjectionMatrix;
+        let imgPos;
+        let dist;
+        let angle;
+        let frustum;
+        const camToImgDir = new THREE.Vector3();
+        const maxDist = 10;
+        const panoImgs = viewer.scene.images360[0].images;
+
+        for (let i = 0; i < panoImgs.length; i++) {
+          if (panoImgs[i].file == viewer.scene.images360[0].focusedImage.file) {
+            continue;
+          }
+          imgPos = new THREE.Vector3().fromArray(panoImgs[i].position);
+          frustum = new THREE.Frustum();
+          cameraViewProjectionMatrix = new THREE.Matrix4();
+          cameraInstance.updateMatrixWorld(); // make sure the camera matrix is updated
+          // cameraInstance.matrixWorldInverse.getInverse(cameraInstance.matrixWorld);
+          cameraInstance.matrixWorldInverse
+            .copy(cameraInstance.matrixWorld)
+            .invert();
+          cameraViewProjectionMatrix.multiplyMatrices(
+            cameraInstance.projectionMatrix,
+            cameraInstance.matrixWorldInverse
+          );
+          frustum.setFromMatrix(cameraViewProjectionMatrix);
+
+          // // if (frustum.containsPoint(imgPos)) {
+          dist = imgPos.distanceTo(camPos);
+          if (dist < maxDist) {
+            camToImgDir.subVectors(imgPos, camPos).normalize();
+            angle = Math.abs(camToImgDir.angleTo(camDir));
+            // tslint:disable-next-line: no-string-literal
+            curSum =
+              weightages["angle"] * angle + weightages["distance"] * dist;
+            if (curSum < totalSum) {
+              selectedPanoImageId = i;
+              totalSum = curSum;
+            }
+          }
+          // // }
+
+          // dist = imgPos.distanceTo(camPos);
+          // if (dist < maxDist) {
+          //     camToImgDir.subVectors(imgPos, camPos).normalize();
+          //     angle = Math.abs(camToImgDir.angleTo(camDir));
+          //     // tslint:disable-next-line: no-string-literal
+          //     // curSum = (weightages['angle'] * angle) + (weightages['distance'] * dist);
+          //     if (angle < totalSum) {
+          //         selectedPanoImageId = i;
+          //         totalSum = angle;
+          //     }
+          // }
+        }
+        if (selectedPanoImageId != undefined) {
+          viewer.scene.images360[0].focus(panoImgs[selectedPanoImageId]);
+        } else {
+          console.warn("No Nearest 360 Images");
+        }
+      }
+
+      function loadFloormap(fpContainerId, fpCanvasId, viewer, pid, tid) {
+        let base_image = new Image();
+        base_image.src = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/floormap/floormap.png`;
+        // return new Promise((resolve, reject) => {
+        let fpCanvas = document.getElementById(fpCanvasId);
+        let fpContainer = document.getElementById(fpContainerId);
+        let viewerDiv = document.getElementById(viewer.canvasId);
+        fpContainer.style.display = viewerMode == "3d" ? "none" : "block";
+
+        viewer.floorMap = {};
+        viewer.floorMap.canvas = fpCanvas;
+        viewer.floorMap.container = fpContainer;
+        viewer.floorMap.div = viewerDiv;
+        viewer.floorMap.coverage = mode.includes("compare") ? 0.25 : 0.15;
+
+        base_image.onload = async () => {
+          viewer.floorMap.image = base_image;
+          updateFPSize(viewer.floorMap);
+
+          let fpMarix = new THREE.Matrix4().set(
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
+          );
+          let fpOffset = [0, 0, 0];
+          const tm_json_raw = await fetch(
+            `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/floormap/tm.json`
+          );
+          if (tm_json_raw.status == 200) {
+            const tm_json = JSON.parse(await tm_json_raw.text());
+            if (tm_json.tm) {
+              fpMarix = new THREE.Matrix4().fromArray(tm_json.tm).transpose();
+              console.log("FP TM Loaded");
+            }
+            viewer.floorMap.tm = fpMarix;
+
+            if (tm_json.offset) {
+              fpOffset = tm_json.offset;
+            }
+            viewer.floorMap.offset = fpOffset;
+          }
+
+          const indoor_images_raw = await fetch(
+            `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/snapshots/${tid}/images.json`
+          );
+          // const indoor_images_raw = await fetch(`http://localhost:1234/indoor_images_15_17_48_66.json`);
+          if (indoor_images_raw.status == 200) {
+            const indoor_images = JSON.parse(await indoor_images_raw.text());
+            console.log("Indoor Images Loaded");
+            loadIcons(
+              indoor_images,
+              fpMarix,
+              base_image,
+              fpCanvas,
+              fpContainer,
+              viewer.floorMap,
+              viewer.canvasId
+            );
+            addUserLocation(
+              "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/fp_user.png",
+              viewer
+            ); // Update Required
+            viewer.floorMap.images = indoor_images;
+          }
+          viewer.isFloorMap = true;
+        };
+        fpContainer.addEventListener("click", (e) => {
+          const clickData = JSON.parse(e.target.getAttribute("data"));
+          if (clickData.id == "viewer_1") {
+            viewer_1.scene.images360[0].images.forEach((pano) => {
+              if (pano.file.split("/").pop() == clickData.name) {
+                viewer_1.scene.images360[0].focus(pano);
+              }
+            });
+          } else if (clickData.id == "viewer_2") {
+            viewer_2.scene.images360[0].images.forEach((pano) => {
+              if (pano.file.split("/").pop() == clickData.name) {
+                viewer_2.scene.images360[0].focus(pano);
+              }
+            });
+          }
+          console.log(clickData.name);
+        });
+      }
+
+      function toggleFloorMap(viewer, cond) {
+        viewer.floorMap.container.style.display = cond ? "block" : "none";
+      }
+
+      function loadIcons(
+        inData,
+        tm,
+        fpImage,
+        fpCanvas,
+        fpContainer,
+        fpStoreData,
+        id
+      ) {
+        let iconSize = 0.01;
+        fpStoreData.icons = [];
+        Object.keys(inData).forEach((imageName) => {
+          const cur_image_pos = inData[imageName].position;
+          const pixelCoords = worldToimage(
+            [cur_image_pos[0], cur_image_pos[1], cur_image_pos[2]],
+            tm
+          );
+          const screenCoords = imageToScreen(pixelCoords, fpImage, fpCanvas);
+          let icon = document.createElement("span");
+          icon.setAttribute("class", "panoIcon");
+          icon.setAttribute(
+            "data",
+            JSON.stringify({ name: imageName, id: id })
+          );
+          icon.style.width = fpCanvas.width * iconSize + "px";
+          icon.style.height = fpCanvas.width * iconSize + "px";
+          icon.style.top = screenCoords[1] - 5 + "px";
+          icon.style.left = screenCoords[0] - 5 + "px";
+          fpContainer.appendChild(icon);
+          fpStoreData.icons.push(icon);
+        });
+      }
+
+      function addUserLocation(path, viewer) {
+        let base_image = new Image();
+        base_image.src = path;
+        return new Promise((resolve, reject) => {
+          base_image.onload = () => {
+            base_image.setAttribute("class", "userIcon");
+            viewer.floorMap.userIcon = base_image;
+            viewer.floorMap.container.appendChild(base_image);
+          };
+        });
+      }
+
+      function calAngle(cx, cy, ex, ey) {
+        var dy = ey - cy;
+        var dx = ex - cx;
+        var theta = Math.atan2(dy, dx); // range (-PI, PI]
+        theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
+        if (theta < 0) theta = 360 + theta; // range [0, 360)
+        return theta - 90 + 180;
+        // return 90 - theta;
+      }
+
+      function updateUserLocation(viewer) {
+        let curView = viewer.scene.view;
+        const position = curView.position.toArray();
+        position[0] += viewer.floorMap.offset[0];
+        position[1] += viewer.floorMap.offset[1];
+        position[2] += viewer.floorMap.offset[2];
+        const pixelCoordsOffset = worldToimage(position, viewer.floorMap.tm);
+        const screenCoords = imageToScreen(
+          pixelCoordsOffset,
+          viewer.floorMap.image,
+          viewer.floorMap.canvas
+        );
+        viewer.floorMap.userIcon.style.left =
+          screenCoords[0] - viewer.floorMap.userIcon.width / 2 + 5 + "px";
+        viewer.floorMap.userIcon.style.top =
+          screenCoords[1] - viewer.floorMap.userIcon.height / 2 + 5 + "px";
+        const camTarget = new THREE.Vector3()
+          .addVectors(curView.position, curView.direction.multiplyScalar(1))
+          .toArray();
+        camTarget[0] += viewer.floorMap.offset[0];
+        camTarget[1] += viewer.floorMap.offset[1];
+        camTarget[2] += viewer.floorMap.offset[2];
+        const camTargetPixel = worldToimage(camTarget, viewer.floorMap.tm);
+        const angle = calAngle(
+          pixelCoordsOffset[0],
+          pixelCoordsOffset[1],
+          camTargetPixel[0],
+          camTargetPixel[1]
+        );
+        viewer.floorMap.userIcon.style.transform = "rotate(" + angle + "deg)";
+      }
+
+      function worldToimage(coords, intm) {
+        const a = new THREE.Vector4(coords[0], coords[1], coords[2], 1);
+        a.applyMatrix4(intm);
+        return [Math.ceil(a.x), Math.ceil(a.y)];
+      }
+
+      function imageToScreen(pix, image, canvas) {
+        const pxx = (pix[0] * canvas.width) / image.naturalWidth;
+        const pyy = (pix[1] * canvas.height) / image.naturalHeight;
+        return [pxx, pyy];
+      }
+
+      function resizeFP(image, fpCanvas, v, coverage) {
+        // let coverage = 0.5;
+        // if (isCompareMode) {
+        // coverage = 0.25;
+        // }
+        // let coverage =
+        if (image.naturalWidth > image.naturalHeight) {
+          fpCanvas.width = v.clientWidth * coverage;
+          fpCanvas.height =
+            fpCanvas.width * (image.naturalHeight / image.naturalWidth);
+        } else {
+          fpCanvas.height = coverage * v.clientWidth;
+          fpCanvas.width =
+            fpCanvas.height * (image.naturalWidth / image.naturalHeight);
+        }
+      }
+
+      function updateFPSize(fpData) {
+        resizeFP(fpData.image, fpData.canvas, fpData.div, fpData.coverage);
+        let context = fpData.canvas.getContext("2d");
+        context.drawImage(
+          fpData.image,
+          0,
+          0,
+          fpData.canvas.width,
+          fpData.canvas.height
+        );
+        if (fpData.icons) {
+          updateFpIcons(fpData);
+        }
+      }
+
+      function updateFpIcons(fpInfo) {
+        let iconSize = 0.02;
+        Object.keys(fpInfo.images).forEach((imageName, index) => {
+          const cur_image_pos = fpInfo.images[imageName].position;
+          const pixelCoords = worldToimage(cur_image_pos, fpInfo.tm);
+          const screenCoords = imageToScreen(
+            pixelCoords,
+            fpInfo.image,
+            fpInfo.canvas
+          );
+          let icon = fpInfo.icons[index];
+          icon.style.width = fpInfo.canvas.width * iconSize + "px";
+          icon.style.height = fpInfo.canvas.width * iconSize + "px";
+          icon.style.top = screenCoords[1] - 5 + "px";
+          icon.style.left = screenCoords[0] - 5 + "px";
+        });
+      }
+
+      function removeFloorMap(viewer) {
+        viewer.floorMap.icons.forEach((icon) => {
+          viewer.floorMap.container.removeChild(icon);
+        });
+        viewer.floorMap.icons = [];
+        viewer.floorMap.container.removeChild(viewer.floorMap.userIcon);
+        viewer.floorMap.userIcon = null;
+        viewer.floorMap.images = null;
+        let context = viewer.floorMap.canvas.getContext("2d");
+        context.clearRect(
+          0,
+          0,
+          viewer.floorMap.canvas.width,
+          viewer.floorMap.canvas.height
+        );
+        viewer.floorMap = {};
+        viewer.isFloorMap = false;
+      }
+
+      async function addMeasure(type, id) {
+        let viewer;
+        if (id == "viewer_1") {
+          viewer = viewer_1;
+          document.getElementById("measure_tool_1").style.display = "block";
+          document
+            .getElementById("measure_top_1")
+            .setAttribute("measure_tool", true);
+        } else {
+          viewer = viewer_2;
+          document.getElementById("measure_tool_2").style.display = "block";
+          document
+            .getElementById("measure_top_2")
+            .setAttribute("measure_tool", true);
+        }
+        if (type == "point") {
+          console.log("Adding Point Measure");
+
+          if (viewerMode == "3d") {
+            let measurement = viewer.measuringTool.startInsertion({
+              showDistances: false,
+              showAngles: false,
+              showCoordinates: true,
+              showArea: false,
+              closed: true,
+              maxMarkers: 1,
+              name: "Point",
+            });
+          } else {
+            let clickHandler = (event) => {
+              const raycaster = new THREE.Raycaster();
+              let pickedObject = undefined;
+
+              const rect = viewer.renderArea.getBoundingClientRect();
+              let pos = {
+                x: event.clientX - rect.left,
+                y: event.clientY - rect.top,
+              };
+
+              // const pos = this.getCanvasRelativePosition(event);
+              let pickPosition = { x: 0, y: 0 };
+              pickPosition.x = (pos.x / viewer.renderArea.clientWidth) * 2 - 1;
+              pickPosition.y =
+                (pos.y / viewer.renderArea.clientHeight) * -2 + 1; // note we flip Y
+
+              raycaster.setFromCamera(pickPosition, viewer.scene.cameraP);
+              let objs =
+                viewerMode == "image"
+                  ? viewer.scene.scene.children
+                  : [viewer.scene.scene.children[0].children[0]];
+              const intersectedObjects = raycaster.intersectObjects(objs, true);
+              if (intersectedObjects.length) {
+                let click_point =
+                  viewerMode == "image"
+                    ? intersectedObjects[2].point
+                    : intersectedObjects[0].point;
+                let measure = new Potree.Measure();
+                measure.showDistances = false;
+                measure.showCoordinates = true;
+                measure.maxMarkers = 1;
+                measure.type = "Point";
+                measure.name = "Point";
+                measure.addMarker(click_point);
+                viewer.scene.addMeasurement(measure);
+              }
+              viewer.renderArea.removeEventListener("click", clickHandler);
+            };
+            setTimeout(() => {
+              viewer.renderArea.addEventListener("click", clickHandler);
+            }, 1);
+          }
+        } else if (type == "distance") {
+          console.log("Adding Distance Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: true,
+            showArea: false,
+            closed: false,
+            name: "Distance",
+          });
+        } else if (type == "area") {
+          console.log("Adding Area Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: true,
+            showArea: true,
+            closed: true,
+            name: "Area",
+          });
+        } else if (type == "height") {
+          console.log("Adding Area Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: false,
+            showHeight: true,
+            showArea: false,
+            closed: false,
+            maxMarkers: 2,
+            name: "Height",
+          });
+        } else if (type == "clear") {
+          viewer.scene.removeAllMeasurements();
+        } else if (type == "save") {
+          let date_time = new Date();
+          let screenShotPath = `${mainProjectID}/structures/${inProjectID}/snapshots/${
+            viewer.tileset
+          }/${date_time.getTime()}.png`;
+          let latest_measure = viewer.scene.measurements.slice(-1)[0];
+          let save_obj = {
+            type: latest_measure.name,
+            points: latest_measure.points.map((point) =>
+              point.position.toArray()
+            ),
+            image: viewer.cur_loaded_image,
+            tileset: viewer.tileset,
+            camera: locate(viewer),
+            screenShot: `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${screenShotPath}`,
+          };
+          console.log("Saving Annotation: ", save_obj);
+          window.top.postMessage(
+            { type: "save-tag", data: JSON.stringify(save_obj) },
+            "*"
+          );
+          takeScreenshot(screenShotPath, viewer);
+        }
+      }
+
+      function toggleVisibility(id, cond) {
+        let div = document.getElementById(id);
+        if (cond) {
+          div.style.display = "block";
+        } else {
+          div.style.display = "none";
+        }
+        updateIconsDisplay();
+      }
+
+      function toggleOrientedImages(id, cond) {
+        if (id == "viewer_1") {
+          viewer_1.scene.orientedImages[0].visible = cond;
+          document.getElementById("cameras_on_1").style.display = cond
+            ? "none"
+            : "inline-block";
+          document.getElementById("cameras_off_1").style.display = cond
+            ? "inline-block"
+            : "none";
+        } else {
+          viewer_2.scene.orientedImages[0].visible = cond;
+          document.getElementById("cameras_on_2").style.display = cond
+            ? "none"
+            : "inline-block";
+          document.getElementById("cameras_off_2").style.display = cond
+            ? "inline-block"
+            : "none";
+        }
+      }
+
+      function actionIconClick(icon) {
+        const inData = JSON.parse(event.target.getAttribute("data"));
+        if (inData) {
+          // parent.postMessage(`${inData.type} button clicked`, "*");
+          if (inData.type == "3d") {
+            if (inData.id == "viewer_1") {
+              viewer_1.controls.elExit.click();
+            } else {
+              viewer_2.controls.elExit.click();
+            }
+          } else if (inData.type == "cameras") {
+            if (inData.id == "viewer_1") {
+              inData.condition == "on"
+                ? toggleOrientedImages("viewer_1", true)
+                : toggleOrientedImages("viewer_1", false);
+            } else {
+              inData.condition == "on"
+                ? toggleOrientedImages("viewer_2", true)
+                : toggleOrientedImages("viewer_2", false);
+            }
+          } else if (inData.type == "compare") {
+            let cam = locate(viewer_1);
+            console.log("3D COMPARE");
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&token=" +
+              token +
+              "&mode=compare_3d" +
+              "&camera=" +
+              JSON.stringify(cam);
+          } else if (inData.type == "bim-compare") {
+            let cam = locate(viewer_1);
+            console.log("BIM COMPARE");
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=compare_bim" +
+              "&camera=" +
+              JSON.stringify(cam) +
+              "&token=" +
+              token;
+          } else if (inData.type == "fp_fullscreen") {
+            if (inData.id == "viewer_1") {
+              if (event.target.id == "fp_fullscreen_1") {
+                document.getElementById("fp_fullscreen_1").style.display =
+                  "none";
+                document.getElementById("fp_minimise_1").style.display =
+                  "block";
+                viewer_1.floorMap.coverage = 0.5;
+                updateFPSize(viewer_1.floorMap);
+              } else {
+                document.getElementById("fp_fullscreen_1").style.display =
+                  "block";
+                document.getElementById("fp_minimise_1").style.display = "none";
+                viewer_1.floorMap.coverage = isCompareMode ? 0.25 : 0.15;
+                updateFPSize(viewer_1.floorMap);
+              }
+            } else if (inData.id == "viewer_2") {
+              if (event.target.id == "fp_fullscreen_2") {
+                document.getElementById("fp_fullscreen_2").style.display =
+                  "none";
+                document.getElementById("fp_minimise_2").style.display =
+                  "block";
+                viewer_2.floorMap.coverage = 0.5;
+                updateFPSize(viewer_2.floorMap);
+              } else {
+                document.getElementById("fp_fullscreen_2").style.display =
+                  "block";
+                document.getElementById("fp_minimise_2").style.display = "none";
+                viewer_2.floorMap.coverage = isCompareMode ? 0.25 : 0.15;
+                updateFPSize(viewer_2.floorMap);
+              }
+            }
+          } else if (inData.type == "compare-close") {
+            let cam = locate(viewer_1);
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=3d" +
+              "&camera=" +
+              JSON.stringify(cam) +
+              "&token=" +
+              token;
+          } else if (inData.type == "bim_legend") {
+            let visible = false;
+            if (event.target.style.opacity == 0.5) {
+              visible = true;
+              event.target.style.opacity = 1;
+            } else {
+              event.target.style.opacity = 0.5;
+            }
+
+            if (inData.id == "viewer_1") {
+              bimFilters(viewer_1, "progress", event.target.id, visible);
+            } else {
+              bimFilters(viewer_2, "progress", event.target.id, visible);
+            }
+          } else if (inData.type == "bim_card_close") {
+            // if (inData.id == 'viewer_1') {
+            // 	closeBimDetailsCard('viewer_1');
+            // } else if (inData.id == 'viewer_2') {
+            // 	closeBimDetailsCard('viewer_2');
+            // }
+          } else if (inData.type == "measure") {
+            if (inData.id == "viewer_1") {
+              if (event.target.getAttribute("measure_tool") == null) {
+                event.target.setAttribute("measure_tool", false);
+              }
+              if (event.target.getAttribute("measure_tool") == "true") {
+                document.getElementById("measure_tool_1").style.display =
+                  "none";
+                event.target.setAttribute("measure_tool", false);
+              } else {
+                document.getElementById("measure_tool_1").style.display =
+                  "block";
+                event.target.setAttribute("measure_tool", true);
+              }
+            } else {
+              if (event.target.getAttribute("measure_tool") == "true") {
+                document.getElementById("measure_tool_2").style.display =
+                  "none";
+                event.target.setAttribute("measure_tool", false);
+              } else {
+                document.getElementById("measure_tool_1").style.display =
+                  "block";
+                event.target.setAttribute("measure_tool", true);
+              }
+            }
+          } else {
+            // event.stopPropagation()
+            addMeasure(inData.type, inData.id);
+          }
+        }
+      }
+
+      function getAllLeafComponents(viewer, callback) {
+        var cbCount = 0; // count pending callbacks
+        var components = []; // store the results
+        var tree; // the instance tree
+
+        function getLeafComponentsRec(parent) {
+          cbCount++;
+          if (tree.getChildCount(parent) != 0) {
+            tree.enumNodeChildren(
+              parent,
+              function (children) {
+                getLeafComponentsRec(children);
+              },
+              false
+            );
+          } else {
+            components.push(parent);
+          }
+          if (--cbCount == 0) callback(components);
+        }
+        viewer.getObjectTree(function (objectTree) {
+          tree = objectTree;
+          var allLeafComponents = getLeafComponentsRec(tree.getRootId());
+        });
+      }
+
+      function getRecursiveGUID(viewer, dbIds) {
+        return new Promise((resolve, reject) => {
+          let guidMapping = {};
+          let guidTodbid = {};
+          let parentMapping = {};
+          let guidToName = {};
+          let dbIdToGuid = {};
+          let property_childs = viewer["properties_child"];
+          let property_head = viewer["properties_head"][0];
+
+          function getGUID(ids) {
+            let dbIdsProcessed = [];
+            viewer.model.getBulkProperties(ids, property_childs, (data) => {
+              data.map((elementDetails) => {
+                let id = elementDetails.properties.filter(
+                  (details) =>
+                    details.displayCategory == property_head &&
+                    details.displayName == property_childs[0]
+                )[0]["displayValue"];
+                let name = elementDetails.properties.filter(
+                  (details) =>
+                    details.displayCategory == property_head &&
+                    details.displayName == property_childs[1]
+                )[0]["displayValue"];
+                if (id) {
+                  guidMapping[elementDetails.dbId] = id;
+                  dbIdsProcessed.push(elementDetails.dbId);
+                  guidToName[id] = name;
+                } else {
+                  console.log("No IFC id for ", elementDetails);
+                }
+              });
+              // console.log('Got ' + dbIdsProcessed.length + ' guids ....')
+              // Get GUID from parent for remaining Ids
+              let remainingDbIds = ids.filter(
+                (lid) => !dbIdsProcessed.includes(lid)
+              );
+              if (remainingDbIds.length) {
+                // console.log('Getting Parents for ' + remainingDbIds.length + ' dbids ....')
+                viewer.model.getBulkProperties(
+                  remainingDbIds,
+                  ["parent"],
+                  (data) => {
+                    let parentsForRemaining = data.map((elementDetails) => {
+                      parentMapping[elementDetails.dbId] =
+                        elementDetails.properties[0].displayValue;
+                      return elementDetails.properties[0].displayValue;
+                    });
+                    getGUID(parentsForRemaining);
+                  }
+                );
+              } else {
+                function getGIdFromParent(id) {
+                  if (guidMapping[parentMapping[id]]) {
+                    return guidMapping[parentMapping[id]];
+                  } else {
+                    return getGIdFromParent(parentMapping[id]);
+                  }
+                }
+
+                dbIds.map((dbid) => {
+                  let gid = guidMapping[dbid];
+                  if (gid) {
+                    if (guidTodbid[gid]) {
+                      guidTodbid[gid].push(dbid);
+                    } else {
+                      guidTodbid[gid] = [dbid];
+                    }
+                    dbIdToGuid[dbid] = gid;
+                  } else {
+                    gid = getGIdFromParent(dbid);
+                    if (guidTodbid[gid]) {
+                      guidTodbid[gid].push(dbid);
+                    } else {
+                      guidTodbid[gid] = [dbid];
+                    }
+                    dbIdToGuid[dbid] = gid;
+                  }
+                });
+
+                // console.log(guidTodbid)
+                console.log(guidToName);
+                bimProgressData[viewer.canvasId] = resolve({
+                  guidMapping: guidTodbid,
+                  dbIdToGuid: dbIdToGuid,
+                });
+              }
+            });
+          }
+
+          console.log("Got " + dbIds.length + " input ids");
+          getGUID(dbIds);
+        });
+      }
+
+      function getguidTodbidMapping(viewer) {
+        return new Promise((resolve, reject) => {
+          getAllLeafComponents(viewer, async (leafIds) => {
+            let guidDetails = await getRecursiveGUID(viewer, leafIds);
+            resolve(guidDetails);
+          });
+        });
+      }
+
+      async function bimProgressView(viewer) {
+        if (
+          inProjectID == "161" ||
+          inProjectID == "165" ||
+          inProjectID == "166"
+        ) {
+          viewer.hideAll();
+          viewer.show(bimProgressData[viewer.canvasId]["green"]);
+          viewer.show(bimProgressData[viewer.canvasId]["blue"]);
+        }
+
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["red"],
+          [1, 0, 0, 0.5],
+          "red"
+        );
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["green"],
+          [0.5, 0.88, 0.22, 0.5],
+          "green"
+        );
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["blue"],
+          [0.95, 0.6, 0.22, 0.5],
+          "blue"
+        );
+
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['red'], 0xFF0000, 'red')
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['green'], 0x71E03A, 'green')
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['blue'], 0xF39B3A, 'blue')
+
+        // viewer.setLightPreset(4)
+        viewer.setQualityLevel(false, false);
+      }
+
+      function bimFilters(viewer, filterType, filterName, visible) {
+        if (filterType == "progress") {
+          if (filterName == "bim_not_started") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["red"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["red"]);
+          } else if (filterName == "bim_complete") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["green"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["green"]);
+          } else if (filterName == "bim_in_progress") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["blue"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["blue"]);
+          }
+        }
+      }
+
+      function bimDefaultView(viewer) {
+        if (
+          inProjectID == "161" ||
+          inProjectID == "165" ||
+          inProjectID == "166"
+        ) {
+          viewer.showAll();
+        }
+        var instanceTree = viewer.model.getData().instanceTree;
+
+        var allDbIdsStr = Object.keys(instanceTree.nodeAccess.dbIdToIndex);
+
+        let dbIds = allDbIdsStr.map(function (id) {
+          return parseInt(id);
+        });
+        viewer.restoreColorMaterial(dbIds);
+        // viewer.setLightPreset(1)
+        viewer.setQualityLevel(true, true);
+      }
+
+      function addProgressButton(viewer) {
+        let group = new Autodesk.Viewing.UI.ControlGroup("BimProgress");
+        viewer.toolbar.addControl(group);
+
+        // Add a new button to the toolbar group
+        let button = new Autodesk.Viewing.UI.Button("progress");
+        // instead of using bootstrap classes e.g.
+        // button.icon.classList.add("fas", "fa-arrows-alt");
+        // you can do this
+        let iconPath =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress.png";
+        button.icon.style = `background-image: url(${iconPath}); background-size: 24px 24px;`;
+
+        button.setToolTip("Progress View");
+
+        button.onClick = function (e) {
+          toggleBimProgressView(viewer);
+
+          // button.icon.classList.add('adsk-viewing-viewer', 'dark-theme', 'adsk-button.active', 'adsk-button')
+          // button.icon.classList.add("fas", "fa-arrows-alt");
+        };
+
+        group.addControl(button);
+
+        toggleBimProgressView(viewer);
+
+        let elems = document.querySelectorAll("[id=bim_not_started]");
+
+        if (viewer.canvasId == "viewer_1") {
+          elems[0].click();
+        } else {
+          elems[1].click();
+        }
+      }
+
+      function toggleBimProgressView(viewer) {
+        console.log("Go to Progress View");
+        bimProgressMode ? bimDefaultView(viewer) : bimProgressView(viewer);
+        if (viewer.canvasId == "viewer_1") {
+          bimProgressMode
+            ? (document.getElementById("bim_legend_1").style.display = "none")
+            : (document.getElementById("bim_legend_1").style.display = "block");
+        } else {
+          bimProgressMode
+            ? (document.getElementById("bim_legend_2").style.display = "none")
+            : (document.getElementById("bim_legend_2").style.display = "block");
+        }
+        bimProgressMode = !bimProgressMode;
+      }
+
+      async function loadProgressView(viewer, projectID, tilesetID) {
+        const progress_data_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/bim_progress.json`
+        );
+        if (progress_data_raw.status == 200) {
+          let guidDetails = await getguidTodbidMapping(viewer);
+          let guidMapping = guidDetails.guidMapping;
+          let guids = Object.keys(guidDetails.guidMapping);
+
+          bimProgressData[viewer.canvasId] = {
+            mapping: guidDetails.guidMapping,
+            dbtoguid: guidDetails.dbIdToGuid,
+            guids: guids,
+          };
+
+          console.log("GUID - DBID mapping done");
+          const progress_data = JSON.parse(await progress_data_raw.text());
+          console.log("BIM progress json loaded");
+
+          bimProgressData[viewer.canvasId]["progress"] = progress_data;
+
+          // let guids = bimProgressData[viewer.canvasId]['guids']
+          // let guidMapping = bimProgressData[viewer.canvasId]['mapping']
+
+          let redArr = guids.filter((key) => progress_data[key] == 0);
+          let greenArr = guids.filter((key) => progress_data[key] == 100);
+          let blueArr = guids.filter(
+            (key) => !redArr.includes(key) && !greenArr.includes(key)
+          );
+          let redDbArr = [];
+          let greenDbArr = [];
+          let blueDbArr = [];
+          if (
+            inProjectID != "161" &&
+            inProjectID != "165" &&
+            inProjectID != "166"
+          ) {
+            redArr.map((id) => (redDbArr = redDbArr.concat(guidMapping[id])));
+          }
+          blueArr.map((id) => (blueDbArr = blueDbArr.concat(guidMapping[id])));
+          greenArr.map(
+            (id) => (greenDbArr = greenDbArr.concat(guidMapping[id]))
+          );
+
+          bimProgressData[viewer.canvasId]["red"] = redDbArr;
+          bimProgressData[viewer.canvasId]["green"] = greenDbArr;
+          bimProgressData[viewer.canvasId]["blue"] = blueDbArr;
+
+          console.log("###############################");
+          console.log(redArr);
+
+          addProgressButton(viewer);
+
+          loadProgressWalk(viewer, projectID, tilesetID);
+        }
+      }
+
+      function select_group_bim(in_guids, viewer, mode, in_field) {
+        let dbArr = [];
+        let guidMapping = bimProgressData[viewer.canvasId]["mapping"];
+        in_guids.map((id) => (dbArr = dbArr.concat(guidMapping[id])));
+
+        if (mode == "material") {
+          bimDefaultView(viewer);
+          viewer.setColorMaterial(dbArr, in_field, "temp_mat");
+        } else if (mode == "visibility") {
+          in_field ? viewer.show(dbArr) : viewer.hide(dbArr);
+        }
+      }
+
+      function remove_group_bim(viewer, mode) {
+        if (mode == "material") {
+          bimDefaultView(viewer);
+        } else if (mode == "visibility") {
+          viewer.showAll();
+        }
+      }
+
+      function locate(viewer) {
+        let camObject;
+        if (viewer.customtype == "potree") {
+          let pos = viewer.scene.view.position.toArray();
+          let tar = viewer.scene.view.getPivot().toArray();
+          let offset = viewer.globalOffset;
+          camObject = {
+            position: [
+              pos[0] + offset[0],
+              pos[1] + offset[1],
+              pos[2] + offset[2],
+            ],
+            target: [
+              tar[0] + offset[0],
+              tar[1] + offset[1],
+              tar[2] + offset[2],
+            ],
+            pitch: viewer.scene.view.pitch,
+            yaw: viewer.scene.view.yaw,
+          };
+        } else if (viewer.customtype == "forge") {
+          const state = viewer.getState({ viewport: true }).viewport;
+          let offset = viewer.globalOffset;
+          camObject = {
+            position: [
+              state.eye[0] + offset[0],
+              state.eye[1] + offset[1],
+              state.eye[2] + offset[2],
+            ],
+            target: [
+              state.target[0] + offset[0],
+              state.target[1] + offset[1],
+              state.target[2] + offset[2],
+            ],
+          };
+        }
+        console.log("Camera : ", camObject);
+        return camObject;
+      }
+
+      function getInverse(org_mat) {
+        var m4 = new THREE.Matrix4();
+        m4.getInverse(org_mat);
+        m4.transpose();
+        return m4.toArray();
+      }
+
+      function flyToContext(info) {
+        let viewer = viewer_1;
+        let offset = viewer.globalOffset;
+        let inCamera_withOffset = {
+          position: new THREE.Vector3().fromArray([
+            info.position[0] - offset[0],
+            info.position[1] - offset[1],
+            info.position[2] - offset[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.target[0] - offset[0],
+            info.target[1] - offset[1],
+            info.target[2] - offset[2],
+          ]),
+          pitch: info.pitch ? info.pitch : null,
+          yaw: info.yaw ? info.yaw : null,
+        };
+        let inCamera = {
+          position: new THREE.Vector3().fromArray([
+            info.position[0],
+            info.position[1],
+            info.position[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.target[0],
+            info.target[1],
+            info.target[2],
+          ]),
+        };
+        if (viewerMode == "image") {
+          getNearestImage(viewer, inCamera_withOffset, "image");
+        } else if (viewerMode == "panorama") {
+          getNearestImage(viewer, inCamera_withOffset, "panorama");
+        } else {
+          if (viewer.customtype == "potree") {
+            viewer.scene.view.setView(
+              inCamera_withOffset.position,
+              inCamera_withOffset.target
+            );
+          } else {
+            viewer.navigation.setPosition(inCamera_withOffset.position);
+            viewer.navigation.setTarget(inCamera_withOffset.target);
+          }
+          if (isCompareMode) {
+            isMouseOnV1 = true;
+            syncViewers();
+          }
+        }
+      }
+
+      function flyToImage(viewer, imageName, inCamera) {
+        if (viewerMode == "panorama") {
+          viewer.scene.images360[0].images.forEach((image) => {
+            if (image.file.split("/").pop() == imageName) {
+              viewer.scene.images360[0].focus(image, true, inCamera);
+            }
+          });
+        } else {
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            if (image.id == imageName) {
+              viewer.scene.orientedImages[0].moveToImage(image);
+            }
+          });
+        }
+      }
+
+      function flyToTagContext(info) {
+        let offset = viewer_1.globalOffset;
+        let inCamera_withOffset = {
+          position: new THREE.Vector3().fromArray([
+            info.camera.position[0] - offset[0],
+            info.camera.position[1] - offset[1],
+            info.camera.position[2] - offset[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.camera.target[0] - offset[0],
+            info.camera.target[1] - offset[1],
+            info.camera.target[2] - offset[2],
+          ]),
+          pitch: info.camera.pitch ? info.camera.pitch : null,
+          yaw: info.camera.yaw ? info.camera.yaw : null,
+        };
+
+        // if (info.image) {
+        // 	flyToImage_AddTag(viewer_1, info.image, inCamera_withOffset, info)
+        // 	if (isCompareMode) {
+        // 		flyToImage_AddTag(viewer_2, info.image, inCamera_withOffset, info)
+        // 	}
+        // } else {
+        // 	console.log('No Tag Support in 3d')
+        // }
+        if (info.image) {
+          if (viewer_1.tileset == info.tileset) {
+            isMouseOnV1 = true;
+
+            tagToAddOnImageLoad = {
+              info: info,
+              viewer: viewer_1,
+            };
+
+            flyToImage(viewer_1, info.image, inCamera_withOffset);
+            // addTag(info, viewer_1)
+            isMouseOnV1 = true;
+          } else if (isCompareMode && viewer_2.tileset == info.tileset) {
+            isMouseOnV1 = false;
+            // addTag(info, viewer_2)
+            tagToAddOnImageLoad = {
+              info: info,
+              viewer: viewer_2,
+            };
+            flyToImage(viewer_2, info.image, inCamera_withOffset);
+            isMouseOnV1 = false;
+          } else {
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              info.tileset +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=" +
+              mode +
+              "&tag=" +
+              JSON.stringify(info) +
+              "&token=" +
+              token;
+          }
+        } else if (isExterior) {
+          console.log("Load 3d tags");
+          // viewer_1.controls.elExit.click();
+          if (viewer_1.cur_loaded_image) {
+            viewer_1.controls.elExit.click();
+          }
+          // if (isCompareMode) {
+          // 	viewer_2.scene.orientedImages[0].release()
+          // }
+
+          setTimeout(() => {
+            if (viewer_1.tileset == info.tileset) {
+              isMouseOnV1 = true;
+              flyToContext(info.camera);
+              addTag(info, viewer_1);
+              isMouseOnV1 = true;
+            } else if (isCompareMode && viewer_2.tileset == info.tileset) {
+              isMouseOnV1 = false;
+              flyToContext(info.camera);
+              addTag(info, viewer_2);
+              isMouseOnV1 = false;
+            } else {
+              window.location.href =
+                "https://internal.constructn.ai/tour1?project=" +
+                mainProjectID +
+                "&structure=" +
+                structure_id +
+                "&snapshot1=" +
+                info.tileset +
+                "&snapshot2=" +
+                inTilesetID2 +
+                "&mode=" +
+                mode +
+                "&tag=" +
+                JSON.stringify(info) +
+                "&token=" +
+                token;
+            }
+          }, 1000);
+        }
+
+        // if (viewerMode == 'image') {
+        // 	getNearestImage(viewer_1,inCamera_withOffset, 'image')
+        // } else if (viewerMode == 'panorama') {
+        // 	getNearestImage(viewer_1,inCamera_withOffset, 'panorama')
+        // } else {
+        // 	if (viewer_1.customtype == 'potree') {
+        // 		viewer.scene.view.setView(inCamera_withOffset.position, inCamera_withOffset.target)
+        // 	} else {
+        // 		viewer_1.navigation.setPosition(inCamera_withOffset.position);
+        // 		viewer_1.navigation.setTarget(inCamera_withOffset.target);
+        // 	}
+        // 	if (isCompareMode) {
+        // 		isMouseOnV1 = true
+        // 		syncViewers();
+        // 	}
+        // }
+      }
+
+      function addTag(inData, viewer) {
+        if (inData.type == "Point") {
+          let measure = new Potree.Measure();
+          measure.showDistances = false;
+          measure.showCoordinates = true;
+          measure.maxMarkers = 1;
+          measure.addMarker(new THREE.Vector3().fromArray(inData.points[0]));
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Distance") {
+          let measure = new Potree.Measure();
+          measure.closed = false;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Area") {
+          let measure = new Potree.Measure();
+          measure.name = "Area";
+          measure.closed = true;
+          measure.showArea = true;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Height") {
+          let measure = new Potree.Measure();
+          measure.name = "Tree Height";
+          measure.closed = false;
+          measure.showDistances = false;
+          measure.showHeight = true;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        }
+      }
+
+      requestAnimationFrame(loop);
+
+      var datesIdMapRight = {};
+      var datesIdMapLeft = {};
+      getDate("#datepickerLeft", datesIdMapLeft, 0, 1);
+      getDate("#datepickerRight", datesIdMapRight, 1, 2);
+
+      function getDate(dateObject, datesMap, defaultValue, snapshotNo) {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: `https://api.dev.constructn.ai/api/v1/snapshots?structure=${structure_id}`,
+            method: "GET",
+            headers: {
+              "Content-Type": "application/json",
+              Authorization: `Bearer ${token}`,
+            },
+            success: (rawData) => {
+              console.log(rawData);
+              if (rawData.result[defaultValue]) {
+                updateDateObject(
+                  rawData,
+                  dateObject,
+                  datesMap,
+                  defaultValue,
+                  snapshotNo
+                );
+              } else if (
+                defaultValue === 1 &&
+                rawData.records[defaultValue - 1]
+              ) {
+                updateDateObject(
+                  rawData,
+                  dateObject,
+                  datesMap,
+                  defaultValue - 1,
+                  snapshotNo
+                );
+              } else {
+                console.log("No records found for Snapshot " + defaultValue);
+              }
+            },
+            error: (e) => {
+              resolve(null);
+            },
+          });
+        });
+      }
+
+      function updateDateObject(
+        rawData,
+        dateObject,
+        datesMap,
+        defaultValue,
+        snapshotNo
+      ) {
+        rawData.result.forEach((record) => {
+          const date = new Date(record["date"]).toISOString().split("T")[0];
+          datesMap[date] = record._id;
+        });
+        console.log(window.location.host);
+        const snapshot = snapshotNo === 1 ? inTilesetID : inTilesetID2;
+        const defaultDate = getValue(datesMap, snapshot)
+          ? getValue(datesMap, snapshot)
+          : new Date(rawData.result[defaultValue]["date"])
+              .toISOString()
+              .split("T")[0];
+        $(dateObject)
+          .datepicker({
+            showOn: "button",
+            buttonImage:
+              "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/calendar.svg",
+            buttonImageOnly: true,
+            buttonText: "Select date",
+            dateFormat: "yy-mm-dd",
+            changeMonth: true,
+            changeYear: true,
+            beforeShowDay: function (date) {
+              var string = jQuery.datepicker.formatDate("yy-mm-dd", date);
+              return [Object.keys(datesMap).indexOf(string) > -1];
+            },
+            onSelect: function (dateText, inst) {
+              let cam = locate(viewer_1);
+              if (snapshotNo === 1) {
+                window.location.href =
+                  "https://internal.constructn.ai/tour1?project=" +
+                  mainProjectID +
+                  "&structure=" +
+                  structure_id +
+                  "&snapshot1=" +
+                  datesMap[dateText] +
+                  "&snapshot2=" +
+                  inTilesetID2 +
+                  "&mode=" +
+                  mode +
+                  "&camera=" +
+                  JSON.stringify(cam) +
+                  "&token=" +
+                  token;
+              } else {
+                window.location.href =
+                  "https://internal.constructn.ai/tour1?project=" +
+                  mainProjectID +
+                  "&structure=" +
+                  structure_id +
+                  "&snapshot1=" +
+                  inTilesetID +
+                  "&snapshot2=" +
+                  datesMap[dateText] +
+                  "&mode=" +
+                  mode +
+                  "&camera=" +
+                  JSON.stringify(cam) +
+                  "&token=" +
+                  token;
+              }
+              // window.location.href = 'https://'+ window.location.host + '/tour?project=' + inProjectID + '&snapshot1=' + datesMap[dateText] + '&snapshot2=' + inTilesetID2 + '&isExterior=0&isFM=1&mode=3d'
+            },
+          })
+          .datepicker("setDate", new Date(defaultDate));
+      }
+
+      function updateIconsDisplay() {
+        Array.from(
+          document.getElementsByClassName("actionButtonsTest")
+        ).forEach((ele) => {
+          $(ele).show();
+          if ($(ele).children(":visible").length === 0) {
+            $(ele).hide();
+          }
+        });
+      }
+
+      function getValue(datesMap, value) {
+        for (let key of Object.keys(datesMap)) {
+          if (datesMap[key] === value) return key;
+        }
+      }
+
+      function takeScreenshot(uploadPath, viewer) {
+        return new Promise((resolve, reject) => {
+          viewer.renderer.domElement.toBlob(function (blob) {
+            // saveAs(blob, "wholePage.png");
+            let file = new File([blob], "task.png");
+            let bodyData = {
+              paths: [uploadPath],
+            };
+
+            $.ajax({
+              url: `https://internal.constructn.ai/api/v1/aws/put-signed-url?bucket=${s3_bucket}`,
+              method: "POST",
+              crossDomain: true,
+              data: JSON.stringify(bodyData),
+              processData: false,
+              contentType: "application/json",
+              success: (reqUrl) => {
+                console.log(reqUrl);
+                $.ajax({
+                  url: reqUrl[0],
+                  method: "PUT",
+                  processData: false,
+                  contentType: false,
+                  data: blob,
+                  success: (reqUrl) => {
+                    console.log("Uploaded Screenshot to S3");
+                    resolve(
+                      `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${uploadPath}`
+                    );
+                  },
+                  error: (e) => {
+                    console.log(e);
+                  },
+                });
+              },
+              error: (e) => {
+                console.log(e);
+              },
+            });
+          });
+          // let div =
+          //     document.getElementById('fpContainer_1');
+
+          // 	return new Promise(resolve => {
+
+          // 		html2canvas(div, {
+          // 			dpi: 200,
+          // 			onrendered: function (canvas) {
+          // 				canvas.toBlob(function(blob) {
+          // 					// saveAs(blob, "wholePage.png");
+          // 					let file = new File([blob], 'task.png')
+        });
+      }
+
+      function fly_progress_walk(in_guid, viewer) {
+        console.log("Progress Walk : Flying to ", in_guid);
+        let db_ids = bimProgressData[viewer.canvasId]["mapping"][in_guid];
+        console.log("DB ID : ", db_ids);
+        viewer.isolate(db_ids);
+        viewer.fitToView(db_ids);
+      }
+
+      function exit_progress_walk(viewer) {
+        viewer.showAll();
+        viewer.fitToView();
+        progress_walk_index = 0;
+      }
+
+      function update_progress_walk(viewer, direction) {
+        if (direction == "next") {
+          progress_walk_index += 1;
+        } else if (direction == "prev") {
+          progress_walk_index -= 1;
+        }
+
+        if (progress_walk_index < 0) {
+          progress_walk_index =
+            bimProgressData[viewer.canvasId]["progress_delta"].length - 1;
+        } else if (
+          progress_walk_index >=
+          bimProgressData[viewer.canvasId]["progress_delta"].length
+        ) {
+          progress_walk_index = 0;
+        }
+
+        fly_progress_walk(
+          bimProgressData[viewer.canvasId]["progress_delta"][
+            progress_walk_index
+          ],
+          viewer
+        );
+      }
+
+      function addProgressWalkButtons(viewer) {
+        // let group = new Autodesk.Viewing.UI.ControlGroup('BimProgress');
+        // viewer.toolbar.addControl(group);
+
+        let group = viewer.toolbar.getControl("BimProgress");
+
+        // Add a new button to the toolbar group
+        let button_walk = new Autodesk.Viewing.UI.Button("progress_walk");
+        let icon_walk =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk.png";
+        button_walk.icon.style = `background-image: url(${icon_walk}); background-size: 24px 24px;`;
+        button_walk.setToolTip("Progress Walk");
+        button_walk.onClick = function (e) {
+          if (progress_walk_mode) {
+            exit_progress_walk(viewer);
+          } else {
+            update_progress_walk(viewer);
+          }
+          progress_walk_mode = !progress_walk_mode;
+        };
+
+        group.addControl(button_walk);
+
+        let button_next = new Autodesk.Viewing.UI.Button("progress_next");
+        let icon_next =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk_next.png";
+        button_next.icon.style = `background-image: url(${icon_next}); background-size: 24px 24px;`;
+        button_next.setToolTip("Next");
+        button_next.onClick = function (e) {
+          if (progress_walk_mode) {
+            update_progress_walk(viewer, "next");
+          }
+        };
+
+        group.addControl(button_next);
+
+        let button_prev = new Autodesk.Viewing.UI.Button("progress_prev");
+        let icon_prev =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk_prev.png";
+        button_prev.icon.style = `background-image: url(${icon_prev}); background-size: 24px 24px;`;
+        button_prev.setToolTip("Prev");
+        button_prev.onClick = function (e) {
+          if (progress_walk_mode) {
+            update_progress_walk(viewer, "prev");
+          }
+        };
+
+        group.addControl(button_prev);
+      }
+
+      async function start_progress_delta_walk(viewer) {
+        // const progress_delta_raw = await fetch(`http://localhost:4200/progress_delta.json`);
+        // if (progress_delta_raw.status == 200) {
+        // const progress_delta = JSON.parse(await progress_delta_raw.text())['delta_elements'];
+        // console.log(progress_delta);
+        // bimProgressData[viewer.canvasId]['progress_delta'] = progress_delta;
+        // fly_progress_walk(bimProgressData[viewer.canvasId]['progress_delta'][progress_walk_index], viewer)
+        // }
+      }
+
+      async function loadProgressWalk(viewer, projectID, tilesetID) {
+        // const progress_delta_raw = await fetch(`http://localhost:4200/progress_delta.json`);
+        const progress_delta_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/bim_progress_delta.json`
+        );
+        if (progress_delta_raw.status == 200) {
+          const progress_delta = JSON.parse(await progress_delta_raw.text())[
+            "delta_elements"
+          ];
+          bimProgressData[viewer.canvasId]["progress_delta"] = progress_delta;
+          addProgressWalkButtons(viewer);
+          console.log("Progress Walk Loaded");
+        }
+      }
+    </script>
+  </body>
+</html>
diff --git a/examples/lion_las.html b/examples/lion_las.html
index 1907e7d8..fe233423 100644
--- a/examples/lion_las.html
+++ b/examples/lion_las.html
@@ -1,77 +1,376 @@
 <!DOCTYPE html>
 <html lang="en">
-<head>
-	<meta charset="utf-8">
-	<meta name="description" content="">
-	<meta name="author" content="">
-	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
-	<title>Potree Viewer</title>
-
-	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
-	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
-	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
-	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
-	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
-</head>
-
-<body>
-	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
-	<script src="../libs/spectrum/spectrum.js"></script>
-	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
-	<script src="../libs/other/BinaryHeap.js"></script>
-	<script src="../libs/tween/tween.min.js"></script>
-	<script src="../libs/d3/d3.js"></script>
-	<script src="../libs/proj4/proj4.js"></script>
-	<script src="../libs/openlayers3/ol.js"></script>
-	<script src="../libs/i18next/i18next.js"></script>
-	<script src="../libs/jstree/jstree.js"></script>
-	<script src="../build/potree/potree.js"></script>
-	<script src="../libs/plasio/js/laslaz.js"></script>
-	
-	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
-	<!-- INCLUDE SETTINGS HERE -->
-	
-	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
-		<div id="potree_render_area" style="background-image: url('../build/potree/resources/images/background.jpg');"></div>
-		<div id="potree_sidebar_container"> </div>
-	</div>
-	
-	<script type="module">
-
-	import * as THREE from "../libs/three.js/build/three.module.js";
-	
-		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
-		
-		viewer.setEDLEnabled(true);
-		viewer.setFOV(60);
-		viewer.setPointBudget(1_000_000);
-		viewer.loadSettingsFromURL();
-		
-		viewer.setDescription("Loading Octree of LAS files");
-		
-		viewer.loadGUI(() => {
-			viewer.setLanguage('en');
-			$("#menu_appearance").next().show();
-			//viewer.toggleSidebar();
-		});
-		
-		// Sigeom
-		Potree.loadPointCloud("../pointclouds/lion_takanawa_las/cloud.js", "lion", function(e){
-			viewer.scene.addPointCloud(e.pointcloud);
-			
-			let material = e.pointcloud.material;
-			material.size = 1;
-			material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
-			
-			e.pointcloud.position.x += 3;
-			e.pointcloud.position.y -= 3;
-			e.pointcloud.position.z += 4;
-			
-			viewer.fitToScreen();
-		});
-		
-	</script>
-	
-	
+  <head>
+    <meta charset="utf-8" />
+    <meta name="description" content="" />
+    <meta name="author" content="" />
+    <meta
+      name="viewport"
+      content="width=device-width, initial-scale=1.0, user-scalable=no"
+    />
+    <title>Potree Viewer</title>
+
+    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jquery-ui/jquery-ui.min.css"
+    />
+    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/spectrum/spectrum.css"
+    />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jstree/themes/mixed/style.css"
+    />
+  </head>
+
+  <body>
+    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
+    <script src="../libs/spectrum/spectrum.js"></script>
+    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
+    <script src="../libs/other/BinaryHeap.js"></script>
+    <script src="../libs/tween/tween.min.js"></script>
+    <script src="../libs/d3/d3.js"></script>
+    <script src="../libs/proj4/proj4.js"></script>
+    <script src="../libs/openlayers3/ol.js"></script>
+    <script src="../libs/i18next/i18next.js"></script>
+    <script src="../libs/jstree/jstree.js"></script>
+    <script src="../build/potree/potree.js"></script>
+    <script src="../libs/plasio/js/laslaz.js"></script>
+
+    <!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
+    <!-- INCLUDE SETTINGS HERE -->
+
+    <div
+      class="potree_container"
+      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
+    >
+      <div
+        id="potree_render_area"
+        style="
+          background-image: url('../build/potree/resources/images/background.jpg');
+        "
+      ></div>
+      <div id="potree_sidebar_container"></div>
+    </div>
+
+    <script type="module">
+      import * as THREE from "../libs/three.js/build/three.module.js";
+      let i = 0;
+      window.viewer = new Potree.Viewer(
+        document.getElementById("potree_render_area")
+      );
+      //viewer.setDescription(`<button id="myButton">Next Image</button> `);
+      viewer.setEDLEnabled(true);
+      viewer.setFOV(60);
+      viewer.setPointBudget(1_000_000);
+      viewer.loadSettingsFromURL();
+      viewer.loadGUI(() => {
+        viewer.setLanguage("en");
+        $("#menu_appearance").next().show();
+      });
+
+      function isMobileDevice() {
+        // Check for a specific mobile user agent string or screen size
+        // Modify this condition based on your requirements
+        console.log("fduihsdfju8iyshdfgyusifdhkjsdfhyuik", navigator.userAgent);
+        return (
+          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+            navigator.userAgent
+          ) || window.innerWidth <= 768
+        );
+      }
+
+      // Execute code only for the mobile version
+      if (isMobileDevice()) {
+        // Your mobile-specific code here
+        console.log("Running on a mobile device");
+        viewer.setDescription(`<button id="myButton">Next Image</button> `);
+        var button = document.getElementById("myButton");
+        button.addEventListener("click", function () {
+          i++;
+          console.log("sdujksdn", i);
+          //   viewer.scene.orientedImages[0].moveToImage(
+          //     viewer.scene.orientedImages[0].images[i]
+          //   );
+          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+          //removeAssets(viewer);
+        });
+      } else {
+        // Your web-specific code here
+        console.log("Running on the web", navigator.userAgent);
+      }
+      // Add a click event listener to the button
+      //   button.addEventListener("click", function () {
+      //     i++;
+      //     nextPanoImage(viewer);
+      //     // viewer.scene.orientedImages[0].moveToImage(
+      //     //   viewer.scene.orientedImages[0].images[i]
+      //     // );
+      //     //viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+      //     //removeAssets(viewer);
+      //   });
+      let viewerMode = "image";
+      // Sigeom
+      Potree.loadPointCloud(
+        "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/pointcloud/cloud.js",
+        "lion",
+        function (e) {
+          viewer.scene.addPointCloud(e.pointcloud);
+
+          let scene = viewer.scene;
+          let pointcloud = e.pointcloud;
+
+          let material = pointcloud.material;
+          material.size = 0.5;
+          material.minSize = 2.0;
+          material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
+          material.shape = Potree.PointShape.SQUARE;
+          material.activeAttributeName = "rgba";
+          let pcMatrix = new THREE.Matrix4().set(
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
+          );
+          let pcOffset = [0, 0, 0];
+          pcMatrix = new THREE.Matrix4()
+            .fromArray([
+              1.000465, 0.003179, 0.000021, -10232.804688, -0.003179, 1.000465,
+              0.000031, -231.655838, -0.000021, -0.000031, 1.00047, -1272.54834,
+              0.0, 0.0, 0.0, 1.0,
+            ])
+            .transpose();
+          pointcloud.applyMatrix(pcMatrix);
+          const assetPosition = pointcloud.position.clone();
+          pointcloud.position.set(
+            assetPosition.x - pcOffset[0],
+            assetPosition.y - pcOffset[1],
+            assetPosition.z - pcOffset[2]
+          );
+          scene.addPointCloud(pointcloud);
+          viewer.fitToScreen();
+          run();
+        }
+      );
+      //   async function run() {
+      //     viewerMode = "image";
+      //     let pcOffset = [0, 0, 0];
+      //     Potree.OrientedImageLoader.load(
+      //       "https://constructn-projects.s3.ap-south-1.amazonaws.com/PRJ156801/structures/STR238477/snapshots/SNP076949/images.json",
+      //       "https://constructn-projects.s3.ap-south-1.amazonaws.com/PRJ156801/structures/STR238477/snapshots/SNP076949/images",
+      //       viewer,
+      //       { tm: new THREE.Matrix4(), offset: pcOffset }
+      //     ).then((images) => {
+      //       console.log("images", images);
+      //       viewer.scene.addOrientedImages(images);
+      //       viewer.scene.orientedImages[0].moveToImage(
+      //         viewer.scene.orientedImages[0].images[i]
+      //       );
+      //     });
+
+      //viewer.mapView.showSources(false);
+      //}
+      //360 images loading
+      async function run() {
+        let pcOffset = [0, 0, 0];
+        Potree.Images360Loader.load(
+          "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/images.json",
+          "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/images",
+          viewer,
+          { tm: new THREE.Matrix4(), offset: pcOffset }
+        ).then((images) => {
+          viewer.scene.add360Images(images);
+          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+        });
+
+        //viewer.mapView.showSources(false);
+      }
+
+      //   function removeAssets(viewer) {
+      //     viewer.scene.scenePointCloud.remove(viewer.scene.pointclouds[0]);
+      //     viewer.scene.pointclouds = [];
+      //     if (viewer.scene.orientedImages.length) {
+      //       viewer.scene.orientedImages[0].release();
+      //       viewer.scene.orientedImages[0].images.forEach((image) => {
+      //         viewer.scene.scene.children[0].remove(image.mesh);
+      //         viewer.scene.scene.children[0].remove(image.line);
+      //       });
+      //       viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+      //       viewer.scene.removeOrientedImages(viewer.scene.orientedImages[0]);
+      //     }
+
+      //     if (viewer.scene.images360.length) {
+      //       viewer.scene.images360[0].unfocus(false);
+      //       viewer.scene.images360[0].images.forEach((image) => {
+      //         viewer.scene.scene.children[0].remove(image.mesh);
+      //       });
+      //       viewer.scene.scene.children[0].remove(
+      //         viewer.scene.images360[0].sphere
+      //       );
+      //       viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+      //       viewer.scene.remove360Images(viewer.scene.images360[0]);
+      //     }
+      //     if (viewer.isFloorMap) {
+      //       removeFloorMap(viewer);
+      //     }
+      //   }
+      document.addEventListener("keydown", (event) => {
+        if (event.key === "Escape") {
+          // Exit in viewer 2 is already handled in contex maintanance
+          if (viewerMode == "image") {
+            viewer.controls.elExit.click();
+          }
+          // else if (viewerMode == 'panorama') {
+          //     viewer.scene.images360[0].unfocus();
+          // }
+        } else if (event.key === "ArrowUp") {
+          // up arrow
+          if (viewerMode == "image") {
+            viewer.controls.elUp.click();
+            // if (isCompareMode && compareType == "potree") {
+            //   viewer_2.controls.elUp.click();
+            // }
+          } else if (viewerMode == "panorama") {
+            if (event.ctrlKey) {
+              setPitch(viewer, 0.5);
+              //   if (isCompareMode && compareType == "potree") {
+              //     setPitch(viewer_2, 0.5);
+              //   }
+            } else {
+              nextPanoImage(viewer);
+            }
+          }
+        } else if (event.key === "ArrowDown") {
+          // down arrow
+          if (viewerMode == "image") {
+            viewer.controls.elDown.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elDown.click();
+            }
+          } else if (viewerMode == "panorama") {
+            if (event.ctrlKey) {
+              setPitch(viewer, -0.5);
+              if (isCompareMode && compareType == "potree") {
+                setPitch(viewer_2, -0.5);
+              }
+            }
+          }
+        } else if (event.key === "ArrowLeft") {
+          // left arrow
+          if (viewerMode == "image") {
+            viewer.controls.elLeft.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elLeft.click();
+            }
+          } else if (viewerMode == "panorama") {
+            setYaw(viewer, 0.5);
+            if (isCompareMode && compareType == "potree") {
+              setYaw(viewer_2, 0.5);
+            }
+          }
+        } else if (event.key === "ArrowRight") {
+          // right arrow
+          if (viewerMode == "image") {
+            viewer.controls.elRight.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elRight.click();
+            }
+          } else if (viewerMode == "panorama") {
+            setYaw(viewer, -0.5);
+            if (isCompareMode && compareType == "potree") {
+              setYaw(viewer_2, -0.5);
+            }
+          }
+        }
+      });
+      //   function nextPanoImage(viewer) {
+      //     let cameraInstance = viewer.scene.cameraP;
+      //     const camDir = new THREE.Vector3();
+      //     cameraInstance.getWorldDirection(camDir);
+      //     camDir.normalize();
+      //     const camPos = cameraInstance.position;
+      //     const weightages = { angle: 0.5, distance: 0.5 };
+      //     let totalSum = 10000;
+      //     let curSum;
+      //     let selectedPanoImageId;
+      //     let cameraViewProjectionMatrix;
+      //     let imgPos;
+      //     let dist;
+      //     let angle;
+      //     let frustum;
+      //     const camToImgDir = new THREE.Vector3();
+      //     const maxDist = 10;
+      //     const panoImgs = viewer.scene.images360[0].images;
+
+      //     for (let i = 0; i < panoImgs.length; i++) {
+      //       if (panoImgs[i].file == viewer.scene.images360[0].focusedImage.file) {
+      //         continue;
+      //       }
+      //       imgPos = new THREE.Vector3().fromArray(panoImgs[i].position);
+      //       frustum = new THREE.Frustum();
+      //       cameraViewProjectionMatrix = new THREE.Matrix4();
+      //       cameraInstance.updateMatrixWorld(); // make sure the camera matrix is updated
+      //       // cameraInstance.matrixWorldInverse.getInverse(cameraInstance.matrixWorld);
+      //       cameraInstance.matrixWorldInverse
+      //         .copy(cameraInstance.matrixWorld)
+      //         .invert();
+      //       cameraViewProjectionMatrix.multiplyMatrices(
+      //         cameraInstance.projectionMatrix,
+      //         cameraInstance.matrixWorldInverse
+      //       );
+      //       frustum.setFromMatrix(cameraViewProjectionMatrix);
+
+      //       // // if (frustum.containsPoint(imgPos)) {
+      //       dist = imgPos.distanceTo(camPos);
+      //       if (dist < maxDist) {
+      //         camToImgDir.subVectors(imgPos, camPos).normalize();
+      //         angle = Math.abs(camToImgDir.angleTo(camDir));
+      //         // tslint:disable-next-line: no-string-literal
+      //         curSum =
+      //           weightages["angle"] * angle + weightages["distance"] * dist;
+      //         if (curSum < totalSum) {
+      //           selectedPanoImageId = i;
+      //           totalSum = curSum;
+      //         }
+      //       }
+      //       // // }
+
+      //       // dist = imgPos.distanceTo(camPos);
+      //       // if (dist < maxDist) {
+      //       //     camToImgDir.subVectors(imgPos, camPos).normalize();
+      //       //     angle = Math.abs(camToImgDir.angleTo(camDir));
+      //       //     // tslint:disable-next-line: no-string-literal
+      //       //     // curSum = (weightages['angle'] * angle) + (weightages['distance'] * dist);
+      //       //     if (angle < totalSum) {
+      //       //         selectedPanoImageId = i;
+      //       //         totalSum = angle;
+      //       //     }
+      //       // }
+      //     }
+      //     if (selectedPanoImageId != undefined) {
+      //       viewer.scene.images360[0].focus(panoImgs[selectedPanoImageId]);
+      //     } else {
+      //       console.warn("No Nearest 360 Images");
+      //     }
+      //   }
+    </script>
   </body>
 </html>
diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 02026fd0..669de80b 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -1,344 +1,305 @@
-
 import * as THREE from "../../../libs/three.js/build/three.module.js";
 import { EventDispatcher } from "../../EventDispatcher.js";
-import {TextSprite} from "../../TextSprite.js";
-
-let sg = new THREE.SphereGeometry(1, 8, 8);
-let sgHigh = new THREE.SphereGeometry(1, 128, 128);
-
-let sm = new THREE.MeshBasicMaterial({side: THREE.BackSide});
-let smHovered = new THREE.MeshBasicMaterial({side: THREE.BackSide, color: 0xff0000});
-
-let raycaster = new THREE.Raycaster();
-let currentlyHovered = null;
-
-let previousView = {
-	controls: null,
-	position: null,
-	target: null,
-};
-
-class Image360{
-
-	constructor(file, time, longitude, latitude, altitude, course, pitch, roll){
-		this.file = file;
-		this.time = time;
-		this.longitude = longitude;
-		this.latitude = latitude;
-		this.altitude = altitude;
-		this.course = course;
-		this.pitch = pitch;
-		this.roll = roll;
-		this.mesh = null;
-	}
-};
-
-export class Images360 extends EventDispatcher{
-
-	constructor(viewer){
-		super();
-
-		this.viewer = viewer;
-
-		this.selectingEnabled = true;
-
-		this.images = [];
-		this.node = new THREE.Object3D();
-
-		this.sphere = new THREE.Mesh(sgHigh, sm);
-		this.sphere.visible = false;
-		this.sphere.scale.set(1000, 1000, 1000);
-		this.node.add(this.sphere);
-		this._visible = true;
-		// this.node.add(label);
-
-		this.focusedImage = null;
-
-		let elUnfocus = document.createElement("input");
-		elUnfocus.type = "button";
-		elUnfocus.value = "unfocus";
-		elUnfocus.style.position = "absolute";
-		elUnfocus.style.right = "10px";
-		elUnfocus.style.bottom = "10px";
-		elUnfocus.style.zIndex = "10000";
-		elUnfocus.style.fontSize = "2em";
-		elUnfocus.addEventListener("click", () => this.unfocus());
-		this.elUnfocus = elUnfocus;
-
-		this.domRoot = viewer.renderer.domElement.parentElement;
-		this.domRoot.appendChild(elUnfocus);
-		this.elUnfocus.style.display = "none";
-
-		viewer.addEventListener("update", () => {
-			this.update(viewer);
-		});
-		viewer.inputHandler.addInputListener(this);
-
-		this.addEventListener("mousedown", () => {
-			if(currentlyHovered && currentlyHovered.image360){
-				this.focus(currentlyHovered.image360);
-			}
-		});
-		
-	};
-
-	set visible(visible){
-		if(this._visible === visible){
-			return;
-		}
-
-
-		for(const image of this.images){
-			image.mesh.visible = visible && (this.focusedImage == null);
-		}
-
-		this.sphere.visible = visible && (this.focusedImage != null);
-		this._visible = visible;
-		this.dispatchEvent({
-			type: "visibility_changed",
-			images: this,
-		});
-	}
-
-	get visible(){
-		return this._visible;
-	}
-
-	focus(image360){
-		if(this.focusedImage !== null){
-			this.unfocus();
-		}
-
-		previousView = {
-			controls: this.viewer.controls,
-			position: this.viewer.scene.view.position.clone(),
-			target: viewer.scene.view.getPivot(),
-		};
-
-		this.viewer.setControls(this.viewer.orbitControls);
-		this.viewer.orbitControls.doubleClockZoomEnabled = false;
-
-		for(let image of this.images){
-			image.mesh.visible = false;
-		}
-
-		this.selectingEnabled = false;
-
-		this.sphere.visible = false;
-
-		this.load(image360).then( () => {
-			this.sphere.visible = true;
-			this.sphere.material.map = image360.texture;
-			this.sphere.material.needsUpdate = true;
-		});
-
-		{ // orientation
-			let {course, pitch, roll} = image360;
-			this.sphere.rotation.set(
-				THREE.Math.degToRad(+roll + 90),
-				THREE.Math.degToRad(-pitch),
-				THREE.Math.degToRad(-course + 90),
-				"ZYX"
-			);
-		}
-
-		this.sphere.position.set(...image360.position);
-
-		let target = new THREE.Vector3(...image360.position);
-		let dir = target.clone().sub(viewer.scene.view.position).normalize();
-		let move = dir.multiplyScalar(0.000001);
-		let newCamPos = target.clone().sub(move);
-
-		viewer.scene.view.setView(
-			newCamPos, 
-			target,
-			500
-		);
-
-		this.focusedImage = image360;
-
-		this.elUnfocus.style.display = "";
-	}
-
-	unfocus(){
-		this.selectingEnabled = true;
-
-		for(let image of this.images){
-			image.mesh.visible = true;
-		}
-
-		let image = this.focusedImage;
-
-		if(image === null){
-			return;
-		}
-
-
-		this.sphere.material.map = null;
-		this.sphere.material.needsUpdate = true;
-		this.sphere.visible = false;
-
-		let pos = viewer.scene.view.position;
-		let target = viewer.scene.view.getPivot();
-		let dir = target.clone().sub(pos).normalize();
-		let move = dir.multiplyScalar(10);
-		let newCamPos = target.clone().sub(move);
-
-		viewer.orbitControls.doubleClockZoomEnabled = true;
-		viewer.setControls(previousView.controls);
-
-		viewer.scene.view.setView(
-			previousView.position, 
-			previousView.target,
-			500
-		);
-
-
-		this.focusedImage = null;
-
-		this.elUnfocus.style.display = "none";
-	}
-
-	load(image360){
-
-		return new Promise(resolve => {
-			let texture = new THREE.TextureLoader().load(image360.file, resolve);
-			texture.wrapS = THREE.RepeatWrapping;
-			texture.repeat.x = -1;
-
-			image360.texture = texture;
-		});
-
-	}
-
-	handleHovering(){
-		let mouse = viewer.inputHandler.mouse;
-		let camera = viewer.scene.getActiveCamera();
-		let domElement = viewer.renderer.domElement;
-
-		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
-
-		// let tStart = performance.now();
-		raycaster.ray.copy(ray);
-		let intersections = raycaster.intersectObjects(this.node.children);
-
-		if(intersections.length === 0){
-			// label.visible = false;
-
-			return;
-		}
-
-		let intersection = intersections[0];
-		currentlyHovered = intersection.object;
-		currentlyHovered.material = smHovered;
-
-		//label.visible = true;
-		//label.setText(currentlyHovered.image360.file);
-		//currentlyHovered.getWorldPosition(label.position);
-	}
-
-	update(){
-
-		let {viewer} = this;
-
-		if(currentlyHovered){
-			currentlyHovered.material = sm;
-			currentlyHovered = null;
-		}
-
-		if(this.selectingEnabled){
-			this.handleHovering();
-		}
-
-	}
-
-};
-
-
-export class Images360Loader{
-
-	static async load(url, viewer, params = {}){
-
-		if(!params.transform){
-			params.transform = {
-				forward: a => a,
-			};
-		}
-		
-		let response = await fetch(`${url}/coordinates.txt`);
-		let text = await response.text();
-
-		let lines = text.split(/\r?\n/);
-		let coordinateLines = lines.slice(1);
-
-		let images360 = new Images360(viewer);
-
-		for(let line of coordinateLines){
-
-			if(line.trim().length === 0){
-				continue;
-			}
-
-			let tokens = line.split(/\t/);
-
-			let [filename, time, long, lat, alt, course, pitch, roll] = tokens;
-			time = parseFloat(time);
-			long = parseFloat(long);
-			lat = parseFloat(lat);
-			alt = parseFloat(alt);
-			course = parseFloat(course);
-			pitch = parseFloat(pitch);
-			roll = parseFloat(roll);
-
-			filename = filename.replace(/"/g, "");
-			let file = `${url}/${filename}`;
-
-			let image360 = new Image360(file, time, long, lat, alt, course, pitch, roll);
-
-			let xy = params.transform.forward([long, lat]);
-			let position = [...xy, alt];
-			image360.position = position;
-
-			images360.images.push(image360);
-		}
-
-		Images360Loader.createSceneNodes(images360, params.transform);
-
-		return images360;
-
-	}
-
-	static createSceneNodes(images360, transform){
-
-		for(let image360 of images360.images){
-			let {longitude, latitude, altitude} = image360;
-			let xy = transform.forward([longitude, latitude]);
-
-			let mesh = new THREE.Mesh(sg, sm);
-			mesh.position.set(...xy, altitude);
-			mesh.scale.set(1, 1, 1);
-			mesh.material.transparent = true;
-			mesh.material.opacity = 0.75;
-			mesh.image360 = image360;
-
-			{ // orientation
-				var {course, pitch, roll} = image360;
-				mesh.rotation.set(
-					THREE.Math.degToRad(+roll + 90),
-					THREE.Math.degToRad(-pitch),
-					THREE.Math.degToRad(-course + 90),
-					"ZYX"
-				);
-			}
-
-			images360.node.add(mesh);
-
-			image360.mesh = mesh;
-		}
-	}
-
-	
-
-};
-
 
+class Image360 {
+  constructor(
+    file,
+    thumbnail,
+    longitude,
+    latitude,
+    altitude,
+    course,
+    pitch,
+    roll
+  ) {
+    this.file = file;
+    this.thumbnail = thumbnail;
+    this.longitude = longitude;
+    this.latitude = latitude;
+    this.altitude = altitude;
+    this.course = course;
+    this.pitch = pitch;
+    this.roll = roll;
+  }
+}
+
+export class Images360 extends EventDispatcher {
+  constructor(viewer) {
+    super();
+
+    this.viewer = viewer;
+
+    this.selectingEnabled = true;
+
+    this.images = [];
+    this.node = new THREE.Object3D();
+
+    this.sphere = new THREE.Mesh(
+      new THREE.SphereGeometry(1, 128, 128),
+      new THREE.MeshBasicMaterial({ side: THREE.BackSide })
+    );
+    this.sphere.visible = false;
+    this.sphere.scale.set(-1000, 1000, 1000);
+
+    this.focus = this.focus.bind(this);
+    this.unfocus = this.unfocus.bind(this);
+    this.node.add(this.sphere);
+    this._visible = true;
+
+    this.focusedImage = null;
+    this.currentlyHovered = null;
+    this.previousView = {
+      controls: null,
+      position: null,
+      target: null,
+    };
+    this.raycaster = new THREE.Raycaster();
+    this.hoverMaterial = new THREE.MeshBasicMaterial({
+      side: THREE.BackSide,
+      color: 0xff0000,
+    });
+    this.sm = new THREE.MeshBasicMaterial({ side: THREE.BackSide });
+
+    // viewer.addEventListener("update", () => {
+    //   this.update(viewer);
+    // });
+    viewer.inputHandler.addInputListener(this);
+
+    this.addEventListener("mousedown", () => {
+      if (this.currentlyHovered && this.currentlyHovered.image360) {
+        this.focus(this.currentlyHovered.image360);
+      }
+    });
+  }
+
+  set visible(visible) {
+    if (this._visible === visible) {
+      return;
+    }
+    this.sphere.visible = visible && this.focusedImage != null;
+    this._visible = visible;
+    this.dispatchEvent({
+      type: "visibility_changed",
+      images: this,
+    });
+  }
+
+  get visible() {
+    return this._visible;
+  }
+
+  focus(image360, sendEvent = true, inTarget = null) {
+    if (this.focusedImage !== null) {
+      this.unfocus();
+    }
+    this.viewer.setEDLOpacity(0);
+    if (sendEvent) {
+      const event = new CustomEvent("panoLoad", {
+        detail: {
+          viewer: this.viewer.canvasId,
+          image: image360,
+        },
+      });
+      document.dispatchEvent(event);
+    }
+
+    this.previousView = {
+      controls: this.viewer.controls,
+      position: this.viewer.scene.view.position.clone(),
+      target: this.viewer.scene.view.getPivot(),
+    };
+
+    this.viewer.setControls(this.viewer.orbitControls);
+    this.viewer.orbitControls.doubleClockZoomEnabled = false;
+
+    this.selectingEnabled = false;
+
+    this.sphere.visible = false;
+
+    this.load(image360).then(() => {
+      this.sphere.visible = true;
+      this.sphere.material.map = image360.texture;
+      this.sphere.material.needsUpdate = true;
+    });
+
+    // orientation
+    let { course, pitch, roll } = image360;
+
+    this.sphere.rotation.set(
+      THREE.Math.degToRad(course),
+      THREE.Math.degToRad(pitch),
+      THREE.Math.degToRad(roll),
+      "XYZ"
+    );
+
+    this.sphere.position.set(...image360.position);
+
+    let target = new THREE.Vector3(...image360.position);
+    let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
+    let move = dir.multiplyScalar(0.000001);
+    let newCamPos = target.clone().sub(move);
+
+    this.viewer.scene.view.setView(newCamPos, target, 500, () => {
+      if (inTarget && inTarget.pitch) {
+        this.viewer.scene.view.pitch = inTarget.pitch;
+        this.viewer.scene.view.yaw = inTarget.yaw;
+      }
+    });
+
+    this.focusedImage = image360;
+  }
+
+  unfocus(sendEvent = true) {
+    this.selectingEnabled = true;
+    this.viewer.setEDLOpacity(1);
+
+    let image = this.focusedImage;
+
+    if (image === null) {
+      return;
+    }
+    delete image.texture;
+    this.sphere.material.map = null;
+    this.sphere.material.needsUpdate = true;
+    this.sphere.visible = false;
+    this.viewer.orbitControls.doubleClockZoomEnabled = true;
+    this.viewer.setControls(this.previousView.controls);
+
+    this.focusedImage = null;
+
+    if (sendEvent) {
+      const event = new CustomEvent("panoUnload", {
+        detail: {
+          viewer: this.viewer.canvasId,
+        },
+      });
+      document.dispatchEvent(event);
+    }
+  }
+
+  load(image360) {
+    let resolved = false;
+    return new Promise((resolve) => {
+      if (image360.texture) {
+        resolve(null);
+      } else {
+        new THREE.TextureLoader().load(
+          image360.thumbnail,
+          (texture) => {
+            image360.texture = texture;
+            resolved = true;
+            resolve(null);
+            loadOrgImage.bind(this)();
+          },
+          undefined,
+          (err) => {
+            loadOrgImage.bind(this)();
+          }
+        );
+        let loadOrgImage = function () {
+          new THREE.TextureLoader().load(image360.file, (texture) => {
+            image360.texture = texture;
+            this.sphere.visible = true;
+            this.sphere.material.map = image360.texture;
+            this.sphere.material.needsUpdate = true;
+            if (!resolved) {
+              resolve(null);
+            }
+            // }
+          });
+        };
+      }
+    });
+  }
+
+  //   handleHovering() {
+  //     let mouse = this.viewer.inputHandler.mouse;
+  //     let camera = this.viewer.scene.getActiveCamera();
+  //     let domElement = this.viewer.renderer.domElement;
+
+  //     let ray = Potree.Utils.mouseToRay(
+  //       mouse,
+  //       camera,
+  //       domElement.clientWidth,
+  //       domElement.clientHeight
+  //     );
+
+  //     this.raycaster.ray.copy(ray);
+  //     let intersections = this.raycaster.intersectObjects(this.node.children);
+
+  //     if (intersections.length === 0) {
+  //       return;
+  //     }
+
+  //     let intersection = intersections[0];
+  //     this.currentlyHovered = intersection.object;
+  //     this.currentlyHovered.material = this.hoverMaterial;
+  //   }
+
+  //   update() {
+  //     let { viewer } = this;
+
+  //     if (this.currentlyHovered) {
+  //       this.currentlyHovered.material = this.sm;
+  //       this.currentlyHovered = null;
+  //     }
+
+  //     if (this.selectingEnabled) {
+  //       // this.handleHovering();
+  //     }
+  //   }
+}
+
+export class Images360Loader {
+  static async load(url, imgsUrl, viewer, tm_data) {
+    let tmatrix, toffset;
+
+    tmatrix = tm_data.tm;
+    toffset = tm_data.offset;
+
+    let response = await fetch(url);
+    let text = await response.text();
+    let imgData = JSON.parse(text);
+
+    let images360 = new Images360(viewer);
+    Object.keys(imgData).forEach((imgName) => {
+      let raw_position = imgData[imgName].position;
+      let rotation = imgData[imgName].rotation;
+
+      const pos = new THREE.Vector4(
+        raw_position[0],
+        raw_position[1],
+        raw_position[2],
+        1
+      );
+      pos.applyMatrix4(tmatrix);
+
+      const long = parseFloat(pos.x - toffset[0]);
+      const lat = parseFloat(pos.y - toffset[1]);
+      const alt = parseFloat(pos.z - toffset[2]);
+      const course = parseFloat(rotation[0]);
+      const pitch = parseFloat(rotation[1]);
+      const roll = parseFloat(rotation[2]);
+
+      let file = `${imgsUrl}/${imgName}`;
+      let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
+      let image360 = new Image360(
+        file,
+        thumbnail,
+        long,
+        lat,
+        alt,
+        course,
+        pitch,
+        roll
+      );
+
+      let position = [long, lat, alt];
+      image360.position = position;
+
+      images360.images.push(image360);
+    });
+
+    return images360;
+  }
+}
diff --git a/src/modules/OrientedImages/OrientedImageControls.js b/src/modules/OrientedImages/OrientedImageControls.js
index 26ac322d..5b43c6ca 100644
--- a/src/modules/OrientedImages/OrientedImageControls.js
+++ b/src/modules/OrientedImages/OrientedImageControls.js
@@ -29,15 +29,24 @@ export class OrientedImageControls extends EventDispatcher{
 
 		this.shear = [0, 0];
 
+		this.changeEvent = new CustomEvent("camerachange");
+
+
 		// const style = ``;
-		this.elUp =    $(`<input type="button" value="ðŸ¡…" style="position: absolute; top: 10px; left: calc(50%); z-index: 1000" />`);
-		this.elRight = $(`<input type="button" value="ðŸ¡†" style="position: absolute; top: calc(50%); right: 10px; z-index: 1000" />`);
-		this.elDown =  $(`<input type="button" value="ðŸ¡‡" style="position: absolute; bottom: 10px; left: calc(50%); z-index: 1000" />`);
-		this.elLeft =  $(`<input type="button" value="ðŸ¡„" style="position: absolute; top: calc(50%); left: 10px; z-index: 1000" />`);
-		this.elExit = $(`<input type="button" value="Back to 3D view" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000" />`);
+		this.elUp =    $(`<input type="button" value="ðŸ¡…" style="position: absolute; top: 10px; left: calc(50%); z-index: 1000; display: none" />`);
+		this.elRight = $(`<input type="button" value="ðŸ¡†" style="position: absolute; top: calc(50%); right: 10px; z-index: 1000; display: none" />`);
+		this.elDown =  $(`<input type="button" value="ðŸ¡‡" style="position: absolute; bottom: 10px; left: calc(50%); z-index: 1000; display: none" />`);
+		this.elLeft =  $(`<input type="button" value="ðŸ¡„" style="position: absolute; top: calc(50%); left: 10px; z-index: 1000; display: none" />`);
+		this.elExit = $(`<input type="button" value="Back to 3D view" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000; display: none" />`);
 
 		this.elExit.click( () => {
 			this.release();
+			const event = new CustomEvent("imageUnload", {
+				detail: {
+					viewer: this.viewer.canvasId
+				}
+			});
+			document.dispatchEvent(event);
 		});
 
 		this.elUp.click(() => {
@@ -68,7 +77,13 @@ export class OrientedImageControls extends EventDispatcher{
 		this.sceneControls = new THREE.Scene();
 
 		let scroll = (e) => {
-			this.fovDelta += -e.delta * 1.0;
+			// this.fovDelta += -e.delta * 1.0;
+			this.shear = [0, 0];
+			let fov = this.viewer.getFOV() + (-e.delta * 5);
+			if (fov > 10 && fov < 100) {
+				this.viewer.setFOV(fov);
+				document.dispatchEvent(this.changeEvent)
+			}
 		};
 
 		this.addEventListener('mousewheel', scroll);
@@ -103,9 +118,13 @@ export class OrientedImageControls extends EventDispatcher{
 		elRoot.append(this.elDown);
 		elRoot.append(this.elLeft);
 		elRoot.append(this.elExit);
+
+		this.viewer.setFOV(30);
+
 	}
 
 	release(){
+
 		this.image = null;
 
 		this.viewer.scene.overrideCamera = null;
@@ -117,7 +136,13 @@ export class OrientedImageControls extends EventDispatcher{
 		this.elExit.detach();
 
 		this.viewer.setFOV(this.originalFOV);
+		this.viewer.scene.cameraP.fov = this.originalFOV;
 		this.viewer.setControls(this.originalControls);
+		this.viewer.controls.enabled = true;
+	}
+
+	stop() {
+		this.release();
 	}
 
 	setScene (scene) {
diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
index ce7a650d..0d95c86e 100644
--- a/src/modules/OrientedImages/OrientedImages.js
+++ b/src/modules/OrientedImages/OrientedImages.js
@@ -1,14 +1,9 @@
-
 import * as THREE from "../../../libs/three.js/build/three.module.js";
-import {OrientedImageControls} from "./OrientedImageControls.js";
+import { OrientedImageControls } from "./OrientedImageControls.js";
 import { EventDispatcher } from "../../EventDispatcher.js";
 
-// https://support.pix4d.com/hc/en-us/articles/205675256-How-are-yaw-pitch-roll-defined
-// https://support.pix4d.com/hc/en-us/articles/202558969-How-are-omega-phi-kappa-defined
-
-function createMaterial(){
-
-	let vertexShader = `
+function createMaterial() {
+  let vertexShader = `
 	uniform float uNear;
 	varying vec2 vUV;
 	varying vec4 vDebug;
@@ -23,7 +18,7 @@ function createMaterial(){
 	}
 	`;
 
-	let fragmentShader = `
+  let fragmentShader = `
 	uniform sampler2D tColor;
 	uniform float uOpacity;
 	varying vec2 vUV;
@@ -34,457 +29,460 @@ function createMaterial(){
 		gl_FragColor.a = uOpacity;
 	}
 	`;
-	const material = new THREE.ShaderMaterial( {
-		uniforms: {
-			// time: { value: 1.0 },
-			// resolution: { value: new THREE.Vector2() }
-			tColor: {value: new THREE.Texture() },
-			uNear: {value: 0.0},
-			uOpacity: {value: 1.0},
-		},
-		vertexShader: vertexShader,
-		fragmentShader: fragmentShader,
-		side: THREE.DoubleSide,
-	} );
-
-	material.side = THREE.DoubleSide;
-
-	return material;
+  const material = new THREE.ShaderMaterial({
+    uniforms: {
+      tColor: { value: new THREE.Texture() },
+      uNear: { value: 0.0 },
+      uOpacity: { value: 1.0 },
+    },
+    vertexShader: vertexShader,
+    fragmentShader: fragmentShader,
+    side: THREE.DoubleSide,
+  });
+
+  material.side = THREE.DoubleSide;
+
+  return material;
 }
 
 const planeGeometry = new THREE.PlaneGeometry(1, 1);
 const lineGeometry = new THREE.Geometry();
 
 lineGeometry.vertices.push(
-	new THREE.Vector3(-0.5, -0.5, 0),
-	new THREE.Vector3( 0.5, -0.5, 0),
-	new THREE.Vector3( 0.5,  0.5, 0),
-	new THREE.Vector3(-0.5,  0.5, 0),
-	new THREE.Vector3(-0.5, -0.5, 0),
+  new THREE.Vector3(-0.5, -0.5, 0),
+  new THREE.Vector3(0.5, -0.5, 0),
+  new THREE.Vector3(0.5, 0.5, 0),
+  new THREE.Vector3(-0.5, 0.5, 0),
+  new THREE.Vector3(-0.5, -0.5, 0)
 );
 
-export class OrientedImage{
-
-	constructor(id){
-
-		this.id = id;
-		this.fov = 1.0;
-		this.position = new THREE.Vector3();
-		this.rotation = new THREE.Vector3();
-		this.width = 0;
-		this.height = 0;
-		this.fov = 1.0;
-
-		const material = createMaterial();
-		const lineMaterial = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
-		this.mesh = new THREE.Mesh(planeGeometry, material);
-		this.line = new THREE.Line(lineGeometry, lineMaterial);
-		this.texture = null;
-
-		this.mesh.orientedImage = this;
-	}
-
-	set(position, rotation, dimension, fov){
-
-		let radians = rotation.map(THREE.Math.degToRad);
-
-		this.position.set(...position);
-		this.mesh.position.set(...position);
-
-		this.rotation.set(...radians);
-		this.mesh.rotation.set(...radians);
-
-		[this.width, this.height] = dimension;
-		this.mesh.scale.set(this.width / this.height, 1, 1);
-
-		this.fov = fov;
-
-		this.updateTransform();
-	}
-
-	updateTransform(){
-		let {mesh, line, fov} = this;
-
-		mesh.updateMatrixWorld();
-		const dir = mesh.getWorldDirection();
-		const alpha = THREE.Math.degToRad(fov / 2);
-		const d = -0.5 / Math.tan(alpha);
-		const move = dir.clone().multiplyScalar(d);
-		mesh.position.add(move);
-
-		line.position.copy(mesh.position);
-		line.scale.copy(mesh.scale);
-		line.rotation.copy(mesh.rotation);
-	}
-
-};
-
-export class OrientedImages extends EventDispatcher{
-
-	constructor(){
-		super();
-
-		this.node = null;
-		this.cameraParams = null;
-		this.imageParams = null;
-		this.images = null;
-		this._visible = true;
-	}
-
-	set visible(visible){
-		if(this._visible === visible){
-			return;
-		}
-
-		for(const image of this.images){
-			image.mesh.visible = visible;
-			image.line.visible = visible;
-		}
-
-		this._visible = visible;
-		this.dispatchEvent({
-			type: "visibility_changed",
-			images: this,
-		});
-	}
-
-	get visible(){
-		return this._visible;
-	}
-
-
-};
-
-export class OrientedImageLoader{
-
-	static async loadCameraParams(path){
-		const res = await fetch(path);
-		const text = await res.text();
-
-		const parser = new DOMParser();
-		const doc = parser.parseFromString(text, "application/xml");
-
-		const width = parseInt(doc.getElementsByTagName("width")[0].textContent);
-		const height = parseInt(doc.getElementsByTagName("height")[0].textContent);
-		const f = parseFloat(doc.getElementsByTagName("f")[0].textContent);
-
-		let a = (height / 2)  / f;
-		let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
-
-		const params = {
-			path: path,
-			width: width,
-			height: height,
-			f: f,
-			fov: fov,
-		};
-
-		return params;
-	}
-
-	static async loadImageParams(path){
-
-		const response = await fetch(path);
-		if(!response.ok){
-			console.error(`failed to load ${path}`);
-			return;
-		}
-
-		const content = await response.text();
-		const lines = content.split(/\r?\n/);
-		const imageParams = [];
-
-		for(let i = 1; i < lines.length; i++){
-			const line = lines[i];
-
-			if(line.startsWith("#")){
-				continue;
-			}
-
-			const tokens = line.split(/\s+/);
-
-			if(tokens.length < 6){
-				continue;
-			}
-
-			const params = {
-				id: tokens[0],
-				x: Number.parseFloat(tokens[1]),
-				y: Number.parseFloat(tokens[2]),
-				z: Number.parseFloat(tokens[3]),
-				omega: Number.parseFloat(tokens[4]),
-				phi: Number.parseFloat(tokens[5]),
-				kappa: Number.parseFloat(tokens[6]),
-			};
-
-			// const whitelist = ["47518.jpg"];
-			// if(whitelist.includes(params.id)){
-			// 	imageParams.push(params);
-			// }
-			imageParams.push(params);
-		}
-
-		// debug
-		//return [imageParams[50]];
-
-		return imageParams;
-	}
+export class OrientedImage {
+  constructor(id) {
+    this.id = id;
+    this.fov = 1.0;
+    this.position = new THREE.Vector3();
+    this.rotation = new THREE.Vector3();
+    this.width = 0;
+    this.height = 0;
+    this.fov = 1.0;
+
+    const material = createMaterial();
+    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
+    this.mesh = new THREE.Mesh(planeGeometry, material);
+    this.line = new THREE.Line(lineGeometry, lineMaterial);
+    this.texture = null;
+
+    this.mesh.orientedImage = this;
+  }
+
+  set(position, rotation, dimension, fov) {
+    let radians = rotation.map(THREE.Math.degToRad);
+
+    this.position.set(...position);
+    this.mesh.position.set(...position);
+
+    this.rotation.set(...radians);
+    this.mesh.rotation.set(...radians);
+
+    [this.width, this.height] = dimension;
+    this.mesh.scale.set(this.width / this.height, 1, 1);
+
+    this.fov = fov;
+
+    this.updateTransform();
+  }
+
+  updateTransform() {
+    let { mesh, line, fov } = this;
+
+    mesh.updateMatrixWorld();
+    var dir = new THREE.Vector3();
+    mesh.getWorldDirection(dir);
+    const alpha = THREE.Math.degToRad(fov / 2);
+    const d = -0.5 / Math.tan(alpha);
+    const move = dir.clone().multiplyScalar(d);
+    mesh.position.add(move);
+
+    line.position.copy(mesh.position);
+    line.scale.copy(mesh.scale);
+    line.rotation.copy(mesh.rotation);
+  }
+}
 
-	static async load(cameraParamsPath, imageParamsPath, viewer){
-
-		const tStart = performance.now();
-
-		const [cameraParams, imageParams] = await Promise.all([
-			OrientedImageLoader.loadCameraParams(cameraParamsPath),
-			OrientedImageLoader.loadImageParams(imageParamsPath),
-		]);
-
-		const orientedImageControls = new OrientedImageControls(viewer);
-		const raycaster = new THREE.Raycaster();
-
-		const tEnd = performance.now();
-		console.log(tEnd - tStart);
-
-		// const sp = new THREE.PlaneGeometry(1, 1);
-		// const lg = new THREE.Geometry();
-
-		// lg.vertices.push(
-		// 	new THREE.Vector3(-0.5, -0.5, 0),
-		// 	new THREE.Vector3( 0.5, -0.5, 0),
-		// 	new THREE.Vector3( 0.5,  0.5, 0),
-		// 	new THREE.Vector3(-0.5,  0.5, 0),
-		// 	new THREE.Vector3(-0.5, -0.5, 0),
-		// );
-
-		const {width, height} = cameraParams;
-		const orientedImages = [];
-		const sceneNode = new THREE.Object3D();
-		sceneNode.name = "oriented_images";
-
-		for(const params of imageParams){
-
-			// const material = createMaterial();
-			// const lm = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
-			// const mesh = new THREE.Mesh(sp, material);
-
-			const {x, y, z, omega, phi, kappa} = params;
-			// const [rx, ry, rz] = [omega, phi, kappa]
-			// 	.map(THREE.Math.degToRad);
-			
-			// mesh.position.set(x, y, z);
-			// mesh.scale.set(width / height, 1, 1);
-			// mesh.rotation.set(rx, ry, rz);
-			// {
-			// 	mesh.updateMatrixWorld();
-			// 	const dir = mesh.getWorldDirection();
-			// 	const alpha = THREE.Math.degToRad(cameraParams.fov / 2);
-			// 	const d = -0.5 / Math.tan(alpha);
-			// 	const move = dir.clone().multiplyScalar(d);
-			// 	mesh.position.add(move);
-			// }
-			// sceneNode.add(mesh);
-
-			// const line = new THREE.Line(lg, lm);
-			// line.position.copy(mesh.position);
-			// line.scale.copy(mesh.scale);
-			// line.rotation.copy(mesh.rotation);
-			// sceneNode.add(line);
-
-			let orientedImage = new OrientedImage(params.id);
-			// orientedImage.setPosition(x, y, z);
-			// orientedImage.setRotation(omega, phi, kappa);
-			// orientedImage.setDimension(width, height);
-			let position = [x, y, z];
-			let rotation = [omega, phi, kappa];
-			let dimension = [width, height];
-			orientedImage.set(position, rotation, dimension, cameraParams.fov);
-
-			sceneNode.add(orientedImage.mesh);
-			sceneNode.add(orientedImage.line);
-			
-			orientedImages.push(orientedImage);
-		}
-
-		let hoveredElement = null;
-		let clipVolume = null;
-
-		const onMouseMove = (evt) => {
-			const tStart = performance.now();
-			if(hoveredElement){
-				hoveredElement.line.material.color.setRGB(0, 1, 0);
-			}
-			evt.preventDefault();
-
-			//var array = getMousePosition( container, evt.clientX, evt.clientY );
-			const rect = viewer.renderer.domElement.getBoundingClientRect();
-			const [x, y] = [evt.clientX, evt.clientY];
-			const array = [ 
-				( x - rect.left ) / rect.width, 
-				( y - rect.top ) / rect.height 
-			];
-			const onClickPosition = new THREE.Vector2(...array);
-			//const intersects = getIntersects(onClickPosition, scene.children);
-			const camera = viewer.scene.getActiveCamera();
-			const mouse = new THREE.Vector3(
-				+ ( onClickPosition.x * 2 ) - 1, 
-				- ( onClickPosition.y * 2 ) + 1 );
-			const objects = orientedImages.map(i => i.mesh);
-			raycaster.setFromCamera( mouse, camera );
-			const intersects = raycaster.intersectObjects( objects );
-			let selectionChanged = false;
-
-			if ( intersects.length > 0){
-				//console.log(intersects);
-				const intersection = intersects[0];
-				const orientedImage = intersection.object.orientedImage;
-				orientedImage.line.material.color.setRGB(1, 0, 0);
-				selectionChanged = hoveredElement !== orientedImage;
-				hoveredElement = orientedImage;
-			}else{
-				hoveredElement = null;
-			}
-
-			let shouldRemoveClipVolume = clipVolume !== null && hoveredElement === null;
-			let shouldAddClipVolume = clipVolume === null && hoveredElement !== null;
-
-			if(clipVolume !== null && (hoveredElement === null || selectionChanged)){
-				// remove existing
-				viewer.scene.removePolygonClipVolume(clipVolume);
-				clipVolume = null;
-			}
-			
-			if(shouldAddClipVolume || selectionChanged){
-				const img = hoveredElement;
-				const fov = cameraParams.fov;
-				const aspect  = cameraParams.width / cameraParams.height;
-				const near = 1.0;
-				const far = 1000 * 1000;
-				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
-				camera.rotation.order = viewer.scene.getActiveCamera().rotation.order;
-				camera.rotation.copy(img.mesh.rotation);
-				{
-					const mesh = img.mesh;
-					const dir = mesh.getWorldDirection();
-					const pos = mesh.position;
-					const alpha = THREE.Math.degToRad(fov / 2);
-					const d = 0.5 / Math.tan(alpha);
-					const newCamPos = pos.clone().add(dir.clone().multiplyScalar(d));
-					const newCamDir = pos.clone().sub(newCamPos);
-					const newCamTarget = new THREE.Vector3().addVectors(
-						newCamPos,
-						newCamDir.clone().multiplyScalar(viewer.getMoveSpeed()));
-					camera.position.copy(newCamPos);
-				}
-				let volume = new Potree.PolygonClipVolume(camera);
-				let m0 = new THREE.Mesh();
-				let m1 = new THREE.Mesh();
-				let m2 = new THREE.Mesh();
-				let m3 = new THREE.Mesh();
-				m0.position.set(-1, -1, 0);
-				m1.position.set( 1, -1, 0);
-				m2.position.set( 1,  1, 0);
-				m3.position.set(-1,  1, 0);
-				volume.markers.push(m0, m1, m2, m3);
-				volume.initialized = true;
-				
-				viewer.scene.addPolygonClipVolume(volume);
-				clipVolume = volume;
-			}
-			const tEnd = performance.now();
-			//console.log(tEnd - tStart);
-		};
-
-		const moveToImage = (image) => {
-			console.log("move to image " + image.id);
-
-			const mesh = image.mesh;
-			const newCamPos = image.position.clone();
-			const newCamTarget = mesh.position.clone();
-
-			viewer.scene.view.setView(newCamPos, newCamTarget, 500, () => {
-				orientedImageControls.capture(image);
-			});
-
-			if(image.texture === null){
-
-				const target = image;
-
-				const tmpImagePath = `${Potree.resourcePath}/images/loading.jpg`;
-				new THREE.TextureLoader().load(tmpImagePath,
-					(texture) => {
-						if(target.texture === null){
-							target.texture = texture;
-							target.mesh.material.uniforms.tColor.value = texture;
-							mesh.material.needsUpdate = true;
-						}
-					}
-				);
-
-				const imagePath = `${imageParamsPath}/../${target.id}`;
-				new THREE.TextureLoader().load(imagePath,
-					(texture) => {
-						target.texture = texture;
-						target.mesh.material.uniforms.tColor.value = texture;
-						mesh.material.needsUpdate = true;
-					}
-				);
-				
-
-			}
-		};
-
-		const onMouseClick = (evt) => {
-
-			if(orientedImageControls.hasSomethingCaptured()){
-				return;
-			}
-
-			if(hoveredElement){
-				moveToImage(hoveredElement);
-			}
-		};
-		viewer.renderer.domElement.addEventListener( 'mousemove', onMouseMove, false );
-		viewer.renderer.domElement.addEventListener( 'mousedown', onMouseClick, false );
-
-		viewer.addEventListener("update", () => {
-
-			for(const image of orientedImages){
-				const world = image.mesh.matrixWorld;
-				const {width, height} = image;
-				const aspect = width / height;
-
-				const camera = viewer.scene.getActiveCamera();
-
-				const imgPos = image.mesh.getWorldPosition(new THREE.Vector3());
-				const camPos = camera.position;
-				const d = camPos.distanceTo(imgPos);
-
-				const minSize = 1; // in degrees of fov
-				const a = THREE.Math.degToRad(minSize);
-				let r = d * Math.tan(a);
-				r = Math.max(r, 1);
-
-
-				image.mesh.scale.set(r * aspect, r, 1);
-				image.line.scale.set(r * aspect, r, 1);
-
-				image.mesh.material.uniforms.uNear.value = camera.near;
-
-			}
-
-		});
-
-		const images = new OrientedImages();
-		images.node = sceneNode;
-		images.cameraParamsPath = cameraParamsPath;
-		images.imageParamsPath = imageParamsPath;
-		images.cameraParams = cameraParams;
-		images.imageParams = imageParams;
-		images.images = orientedImages;
-
-		Potree.debug.moveToImage = moveToImage;
-
-		return images;
-	}
+export class OrientedImages extends EventDispatcher {
+  constructor() {
+    super();
+
+    this.node = null;
+    this.cameraParams = null;
+    this.imageParams = null;
+    this.images = null;
+    this._visible = true;
+    this.focused = null;
+  }
+
+  set visible(visible) {
+    if (this._visible === visible) {
+      return;
+    }
+
+    for (const image of this.images) {
+      image.mesh.visible = visible;
+      image.line.visible = visible;
+    }
+
+    this._visible = visible;
+    this.dispatchEvent({
+      type: "visibility_changed",
+      images: this,
+    });
+  }
+
+  get visible() {
+    return this._visible;
+  }
 }
 
+export class OrientedImageLoader {
+  static async loadCameraParams(path) {
+    const res = await fetch(path);
+    const text = await res.text();
+
+    const parser = new DOMParser();
+    const doc = parser.parseFromString(text, "application/xml");
+
+    const width = parseInt(doc.getElementsByTagName("width")[0].textContent);
+    const height = parseInt(doc.getElementsByTagName("height")[0].textContent);
+    const f = parseFloat(doc.getElementsByTagName("f")[0].textContent);
+
+    let a = height / 2 / f;
+    let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
+
+    const params = {
+      path: path,
+      width: width,
+      height: height,
+      f: f,
+      fov: fov,
+    };
+
+    return params;
+  }
+
+  static async loadImageParams(path, tm) {
+    const response = await fetch(path);
+    if (!response.ok) {
+      console.error(`failed to load ${path}`);
+      return;
+    }
+
+    const content = await response.text();
+
+    const imageParams = [];
+
+    const imgData = JSON.parse(content);
+
+    imgData.camname.forEach((imgName, index) => {
+      const rawPos = new THREE.Vector4(
+        Number.parseFloat(imgData.camX[index]),
+        Number.parseFloat(imgData.camY[index]),
+        Number.parseFloat(imgData.camZ[index]),
+        1
+      );
+      rawPos.applyMatrix4(tm);
+
+      const params = {
+        id: imgData.camname[index],
+        x: Number.parseFloat(imgData.camX[index]),
+        y: Number.parseFloat(imgData.camY[index]),
+        z: Number.parseFloat(imgData.camZ[index]),
+        x_tm: rawPos.x,
+        y_tm: rawPos.y,
+        z_tm: rawPos.z,
+        omega: Number.parseFloat(imgData.camRoll[index]),
+        phi: Number.parseFloat(imgData.camPitch[index]),
+        kappa: Number.parseFloat(imgData.camYaw[index]),
+      };
+
+      imageParams.push(params);
+    });
+
+    const width = parseInt(imgData.camPix[0]);
+    const height = parseInt(imgData.camPix[1]);
+    const f = parseFloat(imgData.camFocal);
+
+    let a = height / 2 / f;
+    let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
+
+    const params = {
+      path: path,
+      width: width,
+      height: height,
+      f: f,
+      fov: fov,
+    };
+
+    return [params, imageParams];
+  }
+
+  static async load(imageParamsPath, imagesPath, viewer, tm_data) {
+    const tStart = performance.now();
+
+    let tmatrix, toffset;
+
+    tmatrix = tm_data.tm;
+    toffset = tm_data.offset;
+
+    const [cameraParams, imageParams] =
+      await OrientedImageLoader.loadImageParams(imageParamsPath, tmatrix);
+
+    const orientedImageControls = new OrientedImageControls(viewer);
+    const raycaster = new THREE.Raycaster();
+
+    const tEnd = performance.now();
+    console.log(tEnd - tStart);
+
+    const { width, height } = cameraParams;
+    const orientedImages = [];
+    const sceneNode = new THREE.Object3D();
+    sceneNode.name = "oriented_images";
+
+    for (const params of imageParams) {
+      const { x, y, z, x_tm, y_tm, z_tm, omega, phi, kappa } = params;
+      let orientedImage = new OrientedImage(params.id);
+      let position = [x, y, z];
+      let rotation = [omega, phi, kappa];
+      let dimension = [width, height];
+      orientedImage.set(position, rotation, dimension, cameraParams.fov);
+      orientedImage.mesh.applyMatrix4(tmatrix);
+      let curMeshPos = orientedImage.mesh.position.clone();
+      orientedImage.mesh.position.set(
+        curMeshPos.x - toffset[0],
+        curMeshPos.y - toffset[1],
+        curMeshPos.z - toffset[2]
+      );
+      orientedImage.line.applyMatrix4(tmatrix);
+      let curLinePos = orientedImage.line.position.clone();
+      orientedImage.line.position.set(
+        curLinePos.x - toffset[0],
+        curLinePos.y - toffset[1],
+        curLinePos.z - toffset[2]
+      );
+      orientedImage.position.set(
+        x_tm - toffset[0],
+        y_tm - toffset[1],
+        z_tm - toffset[2]
+      );
+      sceneNode.add(orientedImage.mesh);
+      sceneNode.add(orientedImage.line);
+
+      orientedImages.push(orientedImage);
+    }
+
+    let hoveredElement = null;
+    let clipVolume = null;
+
+    const images = new OrientedImages();
+    images.node = sceneNode;
+    images.imageParamsPath = imageParamsPath;
+    images.cameraParams = cameraParams;
+    images.imageParams = imageParams;
+    images.images = orientedImages;
+    images.hovered = hoveredElement;
+
+    const onMouseMove = (evt) => {
+      const tStart = performance.now();
+      if (hoveredElement) {
+        hoveredElement.line.material.color.setRGB(0, 1, 0);
+      }
+      evt.preventDefault();
+      if (images.visible) {
+        const rect = viewer.renderer.domElement.getBoundingClientRect();
+        const [x, y] = [evt.clientX, evt.clientY];
+        const array = [
+          (x - rect.left) / rect.width,
+          (y - rect.top) / rect.height,
+        ];
+        const onClickPosition = new THREE.Vector2(...array);
+        const camera = viewer.scene.getActiveCamera();
+        const mouse = new THREE.Vector3(
+          +(onClickPosition.x * 2) - 1,
+          -(onClickPosition.y * 2) + 1
+        );
+        const objects = orientedImages.map((i) => i.mesh);
+        raycaster.setFromCamera(mouse, camera);
+        const intersects = raycaster.intersectObjects(objects);
+        let selectionChanged = false;
+
+        if (intersects.length > 0) {
+          const intersection = intersects[0];
+          const orientedImage = intersection.object.orientedImage;
+          orientedImage.line.material.color.setRGB(1, 0, 0);
+          selectionChanged = hoveredElement !== orientedImage;
+          hoveredElement = orientedImage;
+        } else {
+          hoveredElement = null;
+        }
+
+        let shouldRemoveClipVolume =
+          clipVolume !== null && hoveredElement === null;
+        let shouldAddClipVolume =
+          clipVolume === null && hoveredElement !== null;
+
+        if (
+          clipVolume !== null &&
+          (hoveredElement === null || selectionChanged)
+        ) {
+          // remove existing
+          viewer.scene.removePolygonClipVolume(clipVolume);
+          clipVolume = null;
+        }
+
+        if (shouldAddClipVolume || selectionChanged) {
+          const img = hoveredElement;
+          const fov = cameraParams.fov;
+          const aspect = cameraParams.width / cameraParams.height;
+          const near = 1.0;
+          const far = 1000 * 1000;
+          const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
+          camera.rotation.order = viewer.scene.getActiveCamera().rotation.order;
+          camera.rotation.copy(img.mesh.rotation);
+          {
+            const mesh = img.mesh;
+            const dir = mesh.getWorldDirection();
+            const pos = mesh.position;
+            const alpha = THREE.Math.degToRad(fov / 2);
+            const d = 0.5 / Math.tan(alpha);
+            const newCamPos = pos.clone().add(dir.clone().multiplyScalar(d));
+            const newCamDir = pos.clone().sub(newCamPos);
+            const newCamTarget = new THREE.Vector3().addVectors(
+              newCamPos,
+              newCamDir.clone().multiplyScalar(viewer.getMoveSpeed())
+            );
+            camera.position.copy(newCamPos);
+          }
+          let volume = new Potree.PolygonClipVolume(camera);
+          let m0 = new THREE.Mesh();
+          let m1 = new THREE.Mesh();
+          let m2 = new THREE.Mesh();
+          let m3 = new THREE.Mesh();
+          m0.position.set(-1, -1, 0);
+          m1.position.set(1, -1, 0);
+          m2.position.set(1, 1, 0);
+          m3.position.set(-1, 1, 0);
+          volume.markers.push(m0, m1, m2, m3);
+          volume.initialized = true;
+
+          viewer.scene.addPolygonClipVolume(volume);
+          clipVolume = volume;
+        }
+        const tEnd = performance.now();
+        //console.log(tEnd - tStart);
+      } else {
+        hoveredElement = null;
+        if (clipVolume) {
+          viewer.scene.removePolygonClipVolume(clipVolume);
+          clipVolume = null;
+        }
+      }
+    };
+
+    const moveToImage = async (image, sendEvent = true) => {
+      viewer.controls.enabled = false;
+
+      if (sendEvent) {
+        const event = new CustomEvent("imageLoad", {
+          detail: {
+            viewer: viewer.canvasId,
+            image,
+          },
+        });
+        document.dispatchEvent(event);
+      }
+
+      const mesh = image.mesh;
+      const target = image;
+
+      const newCamPos = image.position.clone();
+      const newCamTarget = mesh.position.clone();
+
+      viewer.scene.view.setView(newCamPos, newCamTarget);
+
+      function loadImageTexture(path) {
+        return new Promise((resolve, reject) => {
+          new THREE.TextureLoader().load(path, (texture) => {
+            resolve(texture);
+          });
+        });
+      }
+
+      function updateTexture(texture) {
+        target.texture = texture;
+        target.mesh.material.uniforms.tColor.value = texture;
+        mesh.material.needsUpdate = true;
+      }
+
+      viewer.scene.orientedImages[0].focused = image;
+      const tmpImagePath = `${imagesPath}/thumbnails/${target.id}`;
+      let texture = await loadImageTexture(tmpImagePath);
+      updateTexture(texture);
+      setTimeout(() => {
+        orientedImageControls.capture(image);
+      }, 100);
+      const imagePath = `${imagesPath}/${target.id}`;
+      let texture_org = await loadImageTexture(imagePath);
+      updateTexture(texture_org);
+      image.texture = texture_org;
+    };
+
+    const onMouseClick = (evt) => {
+      if (orientedImageControls.hasSomethingCaptured()) {
+        return;
+      }
+
+      if (hoveredElement) {
+        moveToImage(hoveredElement);
+      }
+    };
+    viewer.renderer.domElement.addEventListener(
+      "mousemove",
+      onMouseMove,
+      false
+    );
+    viewer.renderer.domElement.addEventListener(
+      "mousedown",
+      onMouseClick,
+      false
+    );
+
+    viewer.addEventListener("update", () => {
+      for (const image of orientedImages) {
+        const world = image.mesh.matrixWorld;
+        const { width, height } = image;
+        const aspect = width / height;
+
+        const camera = viewer.scene.getActiveCamera();
+
+        const imgPos = image.mesh.getWorldPosition(new THREE.Vector3());
+        const camPos = camera.position;
+        const d = camPos.distanceTo(imgPos);
+
+        const minSize = 1; // in degrees of fov
+        const a = THREE.Math.degToRad(minSize);
+        let r = d * Math.tan(a);
+        r = Math.max(r, 1);
+
+        image.mesh.scale.set(r * aspect, r, 1);
+        image.line.scale.set(r * aspect, r, 1);
+
+        image.mesh.material.uniforms.uNear.value = camera.near;
+      }
+    });
+
+    images.moveToImage = moveToImage;
+    images.release = function () {
+      orientedImageControls.release();
+    };
+    return images;
+  }
+}
diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
index 520a11b3..1d21da93 100644
--- a/src/navigation/OrbitControls.js
+++ b/src/navigation/OrbitControls.js
@@ -14,281 +14,317 @@
  */
 
 import * as THREE from "../../libs/three.js/build/three.module.js";
-import {MOUSE} from "../defines.js";
-import {Utils} from "../utils.js";
-import {EventDispatcher} from "../EventDispatcher.js";
-
- 
-export class OrbitControls extends EventDispatcher{
-	
-	constructor(viewer){
-		super();
-		
-		this.viewer = viewer;
-		this.renderer = viewer.renderer;
+import { MOUSE } from "../defines.js";
+import { Utils } from "../utils.js";
+import { EventDispatcher } from "../EventDispatcher.js";
 
-		this.scene = null;
-		this.sceneControls = new THREE.Scene();
-
-		this.rotationSpeed = 5;
+export class OrbitControls extends EventDispatcher {
+  constructor(viewer) {
+    super();
 
-		this.fadeFactor = 20;
-		this.yawDelta = 0;
-		this.pitchDelta = 0;
-		this.panDelta = new THREE.Vector2(0, 0);
-		this.radiusDelta = 0;
+    this.viewer = viewer;
+    this.renderer = viewer.renderer;
 
-		this.doubleClockZoomEnabled = true;
+    this.scene = null;
+    this.sceneControls = new THREE.Scene();
 
-		this.tweens = [];
+    this.rotationSpeed = 5;
 
-		let drag = (e) => {
-			if (e.drag.object !== null) {
-				return;
-			}
-
-			if (e.drag.startHandled === undefined) {
-				e.drag.startHandled = true;
-
-				this.dispatchEvent({type: 'start'});
-			}
-
-			let ndrag = {
-				x: e.drag.lastDrag.x / this.renderer.domElement.clientWidth,
-				y: e.drag.lastDrag.y / this.renderer.domElement.clientHeight
-			};
-
-			if (e.drag.mouse === MOUSE.LEFT) {
-				this.yawDelta += ndrag.x * this.rotationSpeed;
-				this.pitchDelta += ndrag.y * this.rotationSpeed;
-
-				this.stopTweens();
-			} else if (e.drag.mouse === MOUSE.RIGHT) {
-				this.panDelta.x += ndrag.x;
-				this.panDelta.y += ndrag.y;
-
-				this.stopTweens();
-			}
-		};
-
-		let drop = e => {
-			this.dispatchEvent({type: 'end'});
-		};
-
-		let scroll = (e) => {
-			let resolvedRadius = this.scene.view.radius + this.radiusDelta;
-
-			this.radiusDelta += -e.delta * resolvedRadius * 0.1;
-
-			this.stopTweens();
-		};
-
-		let dblclick = (e) => {
-			if(this.doubleClockZoomEnabled){
-				this.zoomToLocation(e.mouse);
-			}
-		};
-
-		let previousTouch = null;
-		let touchStart = e => {
-			previousTouch = e;
-		};
-
-		let touchEnd = e => {
-			previousTouch = e;
-		};
-
-		let touchMove = e => {
-			if (e.touches.length === 2 && previousTouch.touches.length === 2){
-				let prev = previousTouch;
-				let curr = e;
-
-				let prevDX = prev.touches[0].pageX - prev.touches[1].pageX;
-				let prevDY = prev.touches[0].pageY - prev.touches[1].pageY;
-				let prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY);
-
-				let currDX = curr.touches[0].pageX - curr.touches[1].pageX;
-				let currDY = curr.touches[0].pageY - curr.touches[1].pageY;
-				let currDist = Math.sqrt(currDX * currDX + currDY * currDY);
-
-				let delta = currDist / prevDist;
-				let resolvedRadius = this.scene.view.radius + this.radiusDelta;
-				let newRadius = resolvedRadius / delta;
-				this.radiusDelta = newRadius - resolvedRadius;
-
-				this.stopTweens();
-			}else if(e.touches.length === 3 && previousTouch.touches.length === 3){
-				let prev = previousTouch;
-				let curr = e;
-
-				let prevMeanX = (prev.touches[0].pageX + prev.touches[1].pageX + prev.touches[2].pageX) / 3;
-				let prevMeanY = (prev.touches[0].pageY + prev.touches[1].pageY + prev.touches[2].pageY) / 3;
-
-				let currMeanX = (curr.touches[0].pageX + curr.touches[1].pageX + curr.touches[2].pageX) / 3;
-				let currMeanY = (curr.touches[0].pageY + curr.touches[1].pageY + curr.touches[2].pageY) / 3;
-
-				let delta = {
-					x: (currMeanX - prevMeanX) / this.renderer.domElement.clientWidth,
-					y: (currMeanY - prevMeanY) / this.renderer.domElement.clientHeight
-				};
-
-				this.panDelta.x += delta.x;
-				this.panDelta.y += delta.y;
-
-				this.stopTweens();
-			}
-
-			previousTouch = e;
-		};
-
-		this.addEventListener('touchstart', touchStart);
-		this.addEventListener('touchend', touchEnd);
-		this.addEventListener('touchmove', touchMove);
-		this.addEventListener('drag', drag);
-		this.addEventListener('drop', drop);
-		this.addEventListener('mousewheel', scroll);
-		this.addEventListener('dblclick', dblclick);
-	}
-
-	setScene (scene) {
-		this.scene = scene;
-	}
-
-	stop(){
-		this.yawDelta = 0;
-		this.pitchDelta = 0;
-		this.radiusDelta = 0;
-		this.panDelta.set(0, 0);
-	}
-	
-	zoomToLocation(mouse){
-		let camera = this.scene.getActiveCamera();
-		
-		let I = Utils.getMousePointCloudIntersection(
-			mouse,
-			camera,
-			this.viewer,
-			this.scene.pointclouds,
-			{pickClipped: true});
-
-		if (I === null) {
-			return;
-		}
-
-		let targetRadius = 0;
-		{
-			let minimumJumpDistance = 0.2;
-
-			let domElement = this.renderer.domElement;
-			let ray = Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
-
-			let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
-			let lastNode = nodes[nodes.length - 1];
-			let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
-			targetRadius = Math.min(this.scene.view.radius, radius);
-			targetRadius = Math.max(minimumJumpDistance, targetRadius);
-		}
-
-		let d = this.scene.view.direction.multiplyScalar(-1);
-		let cameraTargetPosition = new THREE.Vector3().addVectors(I.location, d.multiplyScalar(targetRadius));
-		// TODO Unused: let controlsTargetPosition = I.location;
-
-		let animationDuration = 600;
-		let easing = TWEEN.Easing.Quartic.Out;
-
-		{ // animate
-			let value = {x: 0};
-			let tween = new TWEEN.Tween(value).to({x: 1}, animationDuration);
-			tween.easing(easing);
-			this.tweens.push(tween);
-
-			let startPos = this.scene.view.position.clone();
-			let targetPos = cameraTargetPosition.clone();
-			let startRadius = this.scene.view.radius;
-			let targetRadius = cameraTargetPosition.distanceTo(I.location);
-
-			tween.onUpdate(() => {
-				let t = value.x;
-				this.scene.view.position.x = (1 - t) * startPos.x + t * targetPos.x;
-				this.scene.view.position.y = (1 - t) * startPos.y + t * targetPos.y;
-				this.scene.view.position.z = (1 - t) * startPos.z + t * targetPos.z;
-
-				this.scene.view.radius = (1 - t) * startRadius + t * targetRadius;
-				this.viewer.setMoveSpeed(this.scene.view.radius);
-			});
-
-			tween.onComplete(() => {
-				this.tweens = this.tweens.filter(e => e !== tween);
-			});
-
-			tween.start();
-		}
-	}
-
-	stopTweens () {
-		this.tweens.forEach(e => e.stop());
-		this.tweens = [];
-	}
-
-	update (delta) {
-		let view = this.scene.view;
-
-		{ // apply rotation
-			let progression = Math.min(1, this.fadeFactor * delta);
-
-			let yaw = view.yaw;
-			let pitch = view.pitch;
-			let pivot = view.getPivot();
-
-			yaw -= progression * this.yawDelta;
-			pitch -= progression * this.pitchDelta;
-
-			view.yaw = yaw;
-			view.pitch = pitch;
-
-			let V = this.scene.view.direction.multiplyScalar(-view.radius);
-			let position = new THREE.Vector3().addVectors(pivot, V);
-
-			view.position.copy(position);
-		}
-
-		{ // apply pan
-			let progression = Math.min(1, this.fadeFactor * delta);
-			let panDistance = progression * view.radius * 3;
-
-			let px = -this.panDelta.x * panDistance;
-			let py = this.panDelta.y * panDistance;
-
-			view.pan(px, py);
-		}
-
-		{ // apply zoom
-			let progression = Math.min(1, this.fadeFactor * delta);
-
-			// let radius = view.radius + progression * this.radiusDelta * view.radius * 0.1;
-			let radius = view.radius + progression * this.radiusDelta;
-
-			let V = view.direction.multiplyScalar(-radius);
-			let position = new THREE.Vector3().addVectors(view.getPivot(), V);
-			view.radius = radius;
-
-			view.position.copy(position);
-		}
+    this.fadeFactor = 20;
+    this.yawDelta = 0;
+    this.pitchDelta = 0;
+    this.panDelta = new THREE.Vector2(0, 0);
+    this.radiusDelta = 0;
 
-		{
-			let speed = view.radius;
-			this.viewer.setMoveSpeed(speed);
-		}
-
-		{ // decelerate over time
-			let progression = Math.min(1, this.fadeFactor * delta);
-			let attenuation = Math.max(0, 1 - this.fadeFactor * delta);
-
-			this.yawDelta *= attenuation;
-			this.pitchDelta *= attenuation;
-			this.panDelta.multiplyScalar(attenuation);
-			// this.radiusDelta *= attenuation;
-			this.radiusDelta -= progression * this.radiusDelta;
-		}
-	}
-};
+    this.doubleClockZoomEnabled = true;
+
+    this.tweens = [];
+
+    this.changeEvent = new CustomEvent("camerachange");
+
+    let drag = (e) => {
+      if (e.drag.object !== null) {
+        return;
+      }
+
+      if (e.drag.startHandled === undefined) {
+        e.drag.startHandled = true;
+
+        this.dispatchEvent({ type: "start" });
+      }
+
+      let ndrag = {
+        x: e.drag.lastDrag.x / this.renderer.domElement.clientWidth,
+        y: e.drag.lastDrag.y / this.renderer.domElement.clientHeight,
+      };
+
+      if (e.drag.mouse === MOUSE.LEFT) {
+        this.yawDelta += ndrag.x * this.rotationSpeed;
+        this.pitchDelta += ndrag.y * this.rotationSpeed;
+
+        this.stopTweens();
+      } else if (e.drag.mouse === MOUSE.RIGHT) {
+        this.panDelta.x += ndrag.x;
+        this.panDelta.y += ndrag.y;
+
+        this.stopTweens();
+      }
+
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let drop = (e) => {
+      this.dispatchEvent({ type: "end" });
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let scroll = (e) => {
+      let resolvedRadius = this.scene.view.radius + this.radiusDelta;
+
+      this.radiusDelta += -e.delta * resolvedRadius * 0.1;
+
+      this.stopTweens();
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let dblclick = (e) => {
+      if (this.doubleClockZoomEnabled) {
+        this.zoomToLocation(e.mouse);
+      }
+    };
+
+    let previousTouch = null;
+    let touchStart = (e) => {
+      previousTouch = e;
+    };
+
+    let touchEnd = (e) => {
+      previousTouch = e;
+    };
+
+    let touchMove = (e) => {
+      if (e.touches.length === 2 && previousTouch.touches.length === 2) {
+        let prev = previousTouch;
+        let curr = e;
+
+        let prevDX = prev.touches[0].pageX - prev.touches[1].pageX;
+        let prevDY = prev.touches[0].pageY - prev.touches[1].pageY;
+        let prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY);
+
+        let currDX = curr.touches[0].pageX - curr.touches[1].pageX;
+        let currDY = curr.touches[0].pageY - curr.touches[1].pageY;
+        let currDist = Math.sqrt(currDX * currDX + currDY * currDY);
+
+        let delta = currDist / prevDist;
+        let resolvedRadius = this.scene.view.radius + this.radiusDelta;
+        let newRadius = resolvedRadius / delta;
+        this.radiusDelta = newRadius - resolvedRadius;
+
+        this.stopTweens();
+      } else if (e.touches.length === 3 && previousTouch.touches.length === 3) {
+        let prev = previousTouch;
+        let curr = e;
+
+        let prevMeanX =
+          (prev.touches[0].pageX +
+            prev.touches[1].pageX +
+            prev.touches[2].pageX) /
+          3;
+        let prevMeanY =
+          (prev.touches[0].pageY +
+            prev.touches[1].pageY +
+            prev.touches[2].pageY) /
+          3;
+
+        let currMeanX =
+          (curr.touches[0].pageX +
+            curr.touches[1].pageX +
+            curr.touches[2].pageX) /
+          3;
+        let currMeanY =
+          (curr.touches[0].pageY +
+            curr.touches[1].pageY +
+            curr.touches[2].pageY) /
+          3;
+
+        let delta = {
+          x: (currMeanX - prevMeanX) / this.renderer.domElement.clientWidth,
+          y: (currMeanY - prevMeanY) / this.renderer.domElement.clientHeight,
+        };
+
+        this.panDelta.x += delta.x;
+        this.panDelta.y += delta.y;
+
+        this.stopTweens();
+      }
+
+      previousTouch = e;
+    };
+
+    this.addEventListener("touchstart", touchStart);
+    this.addEventListener("touchend", touchEnd);
+    this.addEventListener("touchmove", touchMove);
+    this.addEventListener("drag", drag);
+    this.addEventListener("drop", drop);
+    this.addEventListener("mousewheel", scroll);
+    this.addEventListener("dblclick", dblclick);
+  }
+
+  setScene(scene) {
+    this.scene = scene;
+  }
+
+  stop() {
+    this.yawDelta = 0;
+    this.pitchDelta = 0;
+    this.radiusDelta = 0;
+    this.panDelta.set(0, 0);
+  }
+
+  zoomToLocation(mouse) {
+    let camera = this.scene.getActiveCamera();
+
+    let I = Utils.getMousePointCloudIntersection(
+      mouse,
+      camera,
+      this.viewer,
+      this.scene.pointclouds,
+      { pickClipped: true }
+    );
+
+    if (I === null) {
+      return;
+    }
+
+    let targetRadius = 0;
+    {
+      let minimumJumpDistance = 0.2;
+
+      let domElement = this.renderer.domElement;
+      let ray = Utils.mouseToRay(
+        mouse,
+        camera,
+        domElement.clientWidth,
+        domElement.clientHeight
+      );
+
+      let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
+      let lastNode = nodes[nodes.length - 1];
+      let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
+      targetRadius = Math.min(this.scene.view.radius, radius);
+      targetRadius = Math.max(minimumJumpDistance, targetRadius);
+    }
+
+    let d = this.scene.view.direction.multiplyScalar(-1);
+    let cameraTargetPosition = new THREE.Vector3().addVectors(
+      I.location,
+      d.multiplyScalar(targetRadius)
+    );
+    // TODO Unused: let controlsTargetPosition = I.location;
+
+    let animationDuration = 600;
+    let easing = TWEEN.Easing.Quartic.Out;
+
+    {
+      // animate
+      let value = { x: 0 };
+      let tween = new TWEEN.Tween(value).to({ x: 1 }, animationDuration);
+      tween.easing(easing);
+      this.tweens.push(tween);
+
+      let startPos = this.scene.view.position.clone();
+      let targetPos = cameraTargetPosition.clone();
+      let startRadius = this.scene.view.radius;
+      let targetRadius = cameraTargetPosition.distanceTo(I.location);
+
+      tween.onUpdate(() => {
+        let t = value.x;
+        this.scene.view.position.x = (1 - t) * startPos.x + t * targetPos.x;
+        this.scene.view.position.y = (1 - t) * startPos.y + t * targetPos.y;
+        this.scene.view.position.z = (1 - t) * startPos.z + t * targetPos.z;
+
+        this.scene.view.radius = (1 - t) * startRadius + t * targetRadius;
+        this.viewer.setMoveSpeed(this.scene.view.radius);
+        document.dispatchEvent(this.changeEvent);
+      });
+
+      tween.onComplete(() => {
+        this.tweens = this.tweens.filter((e) => e !== tween);
+        document.dispatchEvent(this.changeEvent);
+      });
+
+      tween.start();
+    }
+  }
+
+  stopTweens() {
+    this.tweens.forEach((e) => e.stop());
+    this.tweens = [];
+  }
+
+  update(delta) {
+    let view = this.scene.view;
+
+    {
+      // apply rotation
+      let progression = Math.min(1, this.fadeFactor * delta);
+
+      let yaw = view.yaw;
+      let pitch = view.pitch;
+      let pivot = view.getPivot();
+
+      yaw -= progression * this.yawDelta;
+      pitch -= progression * this.pitchDelta;
+
+      view.yaw = yaw;
+      view.pitch = pitch;
+
+      let V = this.scene.view.direction.multiplyScalar(-view.radius);
+      let position = new THREE.Vector3().addVectors(pivot, V);
+
+      view.position.copy(position);
+    }
+
+    {
+      // apply pan
+      let progression = Math.min(1, this.fadeFactor * delta);
+      let panDistance = progression * view.radius * 3;
+
+      let px = -this.panDelta.x * panDistance;
+      let py = this.panDelta.y * panDistance;
+
+      view.pan(px, py);
+    }
+
+    {
+      // apply zoom
+      let progression = Math.min(1, this.fadeFactor * delta);
+
+      // let radius = view.radius + progression * this.radiusDelta * view.radius * 0.1;
+      let radius = view.radius + progression * this.radiusDelta;
+
+      let V = view.direction.multiplyScalar(-radius);
+      let position = new THREE.Vector3().addVectors(view.getPivot(), V);
+      view.radius = radius;
+
+      view.position.copy(position);
+    }
+
+    {
+      let speed = view.radius;
+      this.viewer.setMoveSpeed(speed);
+    }
+
+    {
+      // decelerate over time
+      let progression = Math.min(1, this.fadeFactor * delta);
+      let attenuation = Math.max(0, 1 - this.fadeFactor * delta);
+
+      this.yawDelta *= attenuation;
+      this.pitchDelta *= attenuation;
+      this.panDelta.multiplyScalar(attenuation);
+      // this.radiusDelta *= attenuation;
+      this.radiusDelta -= progression * this.radiusDelta;
+    }
+  }
+}
diff --git a/src/viewer/Scene.js b/src/viewer/Scene.js
index d0008ac8..f656bf6a 100644
--- a/src/viewer/Scene.js
+++ b/src/viewer/Scene.js
@@ -1,437 +1,450 @@
-
 import * as THREE from "../../libs/three.js/build/three.module.js";
-import {Annotation} from "../Annotation.js";
-import {CameraMode} from "../defines.js";
-import {View} from "./View.js";
-import {Utils} from "../utils.js";
-import {EventDispatcher} from "../EventDispatcher.js";
-
-
-export class Scene extends EventDispatcher{
-
-	constructor(){
-		super();
-
-		this.annotations = new Annotation();
-		
-		this.scene = new THREE.Scene();
-		this.sceneBG = new THREE.Scene();
-		this.scenePointCloud = new THREE.Scene();
-
-		this.cameraP = new THREE.PerspectiveCamera(this.fov, 1, 0.1, 1000*1000);
-		this.cameraO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000*1000);
-		this.cameraVR = new THREE.PerspectiveCamera();
-		this.cameraBG = new THREE.Camera();
-		this.cameraScreenSpace = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
-		this.cameraMode = CameraMode.PERSPECTIVE;
-		this.overrideCamera = null;
-		this.pointclouds = [];
-
-		this.measurements = [];
-		this.profiles = [];
-		this.volumes = [];
-		this.polygonClipVolumes = [];
-		this.cameraAnimations = [];
-		this.orientedImages = [];
-		this.images360 = [];
-		this.geopackages = [];
-		
-		this.fpControls = null;
-		this.orbitControls = null;
-		this.earthControls = null;
-		this.geoControls = null;
-		this.deviceControls = null;
-		this.inputHandler = null;
-
-		this.view = new View();
-
-		this.directionalLight = null;
-
-		this.initialize();
-	}
-
-	estimateHeightAt (position) {
-		let height = null;
-		let fromSpacing = Infinity;
-
-		for (let pointcloud of this.pointclouds) {
-			if (pointcloud.root.geometryNode === undefined) {
-				continue;
-			}
-
-			let pHeight = null;
-			let pFromSpacing = Infinity;
-
-			let lpos = position.clone().sub(pointcloud.position);
-			lpos.z = 0;
-			let ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));
-
-			let stack = [pointcloud.root];
-			while (stack.length > 0) {
-				let node = stack.pop();
-				let box = node.getBoundingBox();
-
-				let inside = ray.intersectBox(box);
-
-				if (!inside) {
-					continue;
-				}
-
-				let h = node.geometryNode.mean.z +
-					pointcloud.position.z +
-					node.geometryNode.boundingBox.min.z;
-
-				if (node.geometryNode.spacing <= pFromSpacing) {
-					pHeight = h;
-					pFromSpacing = node.geometryNode.spacing;
-				}
-
-				for (let index of Object.keys(node.children)) {
-					let child = node.children[index];
-					if (child.geometryNode) {
-						stack.push(node.children[index]);
-					}
-				}
-			}
-
-			if (height === null || pFromSpacing < fromSpacing) {
-				height = pHeight;
-				fromSpacing = pFromSpacing;
-			}
-		}
-
-		return height;
-	}
-	
-	getBoundingBox(pointclouds = this.pointclouds){
-		let box = new THREE.Box3();
-
-		this.scenePointCloud.updateMatrixWorld(true);
-		this.referenceFrame.updateMatrixWorld(true);
-
-		for (let pointcloud of pointclouds) {
-			pointcloud.updateMatrixWorld(true);
-
-			let pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox ? pointcloud.pcoGeometry.tightBoundingBox : pointcloud.boundingBox;
-			let boxWorld = Utils.computeTransformedBoundingBox(pointcloudBox, pointcloud.matrixWorld);
-			box.union(boxWorld);
-		}
-
-		return box;
-	}
-
-	addPointCloud (pointcloud) {
-		this.pointclouds.push(pointcloud);
-		this.scenePointCloud.add(pointcloud);
-
-		this.dispatchEvent({
-			type: 'pointcloud_added',
-			pointcloud: pointcloud
-		});
-	}
-
-	addVolume (volume) {
-		this.volumes.push(volume);
-		this.dispatchEvent({
-			'type': 'volume_added',
-			'scene': this,
-			'volume': volume
-		});
-	}
-
-	addOrientedImages(images){
-		this.orientedImages.push(images);
-		this.scene.add(images.node);
-
-		this.dispatchEvent({
-			'type': 'oriented_images_added',
-			'scene': this,
-			'images': images
-		});
-	};
-
-	removeOrientedImages(images){
-		let index = this.orientedImages.indexOf(images);
-		if (index > -1) {
-			this.orientedImages.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'oriented_images_removed',
-				'scene': this,
-				'images': images
-			});
-		}
-	};
-
-	add360Images(images){
-		this.images360.push(images);
-		this.scene.add(images.node);
-
-		this.dispatchEvent({
-			'type': '360_images_added',
-			'scene': this,
-			'images': images
-		});
-	}
-
-	remove360Images(images){
-		let index = this.images360.indexOf(images);
-		if (index > -1) {
-			this.images360.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': '360_images_removed',
-				'scene': this,
-				'images': images
-			});
-		}
-	}
-
-	addGeopackage(geopackage){
-		this.geopackages.push(geopackage);
-		this.scene.add(geopackage.node);
-
-		this.dispatchEvent({
-			'type': 'geopackage_added',
-			'scene': this,
-			'geopackage': geopackage
-		});
-	};
-
-	removeGeopackage(geopackage){
-		let index = this.geopackages.indexOf(geopackage);
-		if (index > -1) {
-			this.geopackages.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'geopackage_removed',
-				'scene': this,
-				'geopackage': geopackage
-			});
-		}
-	};
-
-	removeVolume (volume) {
-		let index = this.volumes.indexOf(volume);
-		if (index > -1) {
-			this.volumes.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'volume_removed',
-				'scene': this,
-				'volume': volume
-			});
-		}
-	};
-
-	addCameraAnimation(animation) {
-		this.cameraAnimations.push(animation);
-		this.dispatchEvent({
-			'type': 'camera_animation_added',
-			'scene': this,
-			'animation': animation
-		});
-	};
-
-	removeCameraAnimation(animation){
-		let index = this.cameraAnimations.indexOf(volume);
-		if (index > -1) {
-			this.cameraAnimations.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'camera_animation_removed',
-				'scene': this,
-				'animation': animation
-			});
-		}
-	};
-
-	addPolygonClipVolume(volume){
-		this.polygonClipVolumes.push(volume);
-		this.dispatchEvent({
-			"type": "polygon_clip_volume_added",
-			"scene": this,
-			"volume": volume
-		});
-	};
-	
-	removePolygonClipVolume(volume){
-		let index = this.polygonClipVolumes.indexOf(volume);
-		if (index > -1) {
-			this.polygonClipVolumes.splice(index, 1);
-			this.dispatchEvent({
-				"type": "polygon_clip_volume_removed",
-				"scene": this,
-				"volume": volume
-			});
-		}
-	};
-	
-	addMeasurement(measurement){
-		measurement.lengthUnit = this.lengthUnit;
-		measurement.lengthUnitDisplay = this.lengthUnitDisplay;
-		this.measurements.push(measurement);
-		this.dispatchEvent({
-			'type': 'measurement_added',
-			'scene': this,
-			'measurement': measurement
-		});
-	};
-
-	removeMeasurement (measurement) {
-		let index = this.measurements.indexOf(measurement);
-		if (index > -1) {
-			this.measurements.splice(index, 1);
-			this.dispatchEvent({
-				'type': 'measurement_removed',
-				'scene': this,
-				'measurement': measurement
-			});
-		}
-	}
-
-	addProfile (profile) {
-		this.profiles.push(profile);
-		this.dispatchEvent({
-			'type': 'profile_added',
-			'scene': this,
-			'profile': profile
-		});
-	}
-
-	removeProfile (profile) {
-		let index = this.profiles.indexOf(profile);
-		if (index > -1) {
-			this.profiles.splice(index, 1);
-			this.dispatchEvent({
-				'type': 'profile_removed',
-				'scene': this,
-				'profile': profile
-			});
-		}
-	}
-
-	removeAllMeasurements () {
-		while (this.measurements.length > 0) {
-			this.removeMeasurement(this.measurements[0]);
-		}
-
-		while (this.profiles.length > 0) {
-			this.removeProfile(this.profiles[0]);
-		}
-
-		while (this.volumes.length > 0) {
-			this.removeVolume(this.volumes[0]);
-		}
-	}
-
-	removeAllClipVolumes(){
-		let clipVolumes = this.volumes.filter(volume => volume.clip === true);
-		for(let clipVolume of clipVolumes){
-			this.removeVolume(clipVolume);
-		}
-
-		while(this.polygonClipVolumes.length > 0){
-			this.removePolygonClipVolume(this.polygonClipVolumes[0]);
-		}
-	}
-
-	getActiveCamera() {
-
-		if(this.overrideCamera){
-			return this.overrideCamera;
-		}
-
-		if(this.cameraMode === CameraMode.PERSPECTIVE){
-			return this.cameraP;
-		}else if(this.cameraMode === CameraMode.ORTHOGRAPHIC){
-			return this.cameraO;
-		}else if(this.cameraMode === CameraMode.VR){
-			return this.cameraVR;
-		}
-
-		return null;
-	}
-	
-	initialize(){
-		
-		this.referenceFrame = new THREE.Object3D();
-		this.referenceFrame.matrixAutoUpdate = false;
-		this.scenePointCloud.add(this.referenceFrame);
-
-		this.cameraP.up.set(0, 0, 1);
-		this.cameraP.position.set(1000, 1000, 1000);
-		this.cameraO.up.set(0, 0, 1);
-		this.cameraO.position.set(1000, 1000, 1000);
-		//this.camera.rotation.y = -Math.PI / 4;
-		//this.camera.rotation.x = -Math.PI / 6;
-		this.cameraScreenSpace.lookAt(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0));
-		
-		this.directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
-		this.directionalLight.position.set( 10, 10, 10 );
-		this.directionalLight.lookAt( new THREE.Vector3(0, 0, 0));
-		this.scenePointCloud.add( this.directionalLight );
-		
-		let light = new THREE.AmbientLight( 0x555555 ); // soft white light
-		this.scenePointCloud.add( light );
-
-		{ // background
-			let texture = Utils.createBackgroundTexture(512, 512);
-
-			texture.minFilter = texture.magFilter = THREE.NearestFilter;
-			texture.minFilter = texture.magFilter = THREE.LinearFilter;
-			let bg = new THREE.Mesh(
-				new THREE.PlaneBufferGeometry(2, 2, 1),
-				new THREE.MeshBasicMaterial({
-					map: texture
-				})
-			);
-			bg.material.depthTest = false;
-			bg.material.depthWrite = false;
-			this.sceneBG.add(bg);
-		}
-
-		// { // lights
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(10, 10, 1);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(-10, 10, 1);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(0, -10, 20);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-		// }
-	}
-	
-	addAnnotation(position, args = {}){		
-		if(position instanceof Array){
-			args.position = new THREE.Vector3().fromArray(position);
-		} else if (position.x != null) {
-			args.position = position;
-		}
-		let annotation = new Annotation(args);
-		this.annotations.add(annotation);
-
-		return annotation;
-	}
-
-	getAnnotations () {
-		return this.annotations;
-	};
-
-	removeAnnotation(annotationToRemove) {
-		this.annotations.remove(annotationToRemove);
-	}
-};
+import { Annotation } from "../Annotation.js";
+import { CameraMode } from "../defines.js";
+import { View } from "./View.js";
+import { Utils } from "../utils.js";
+import { EventDispatcher } from "../EventDispatcher.js";
+
+export class Scene extends EventDispatcher {
+  constructor() {
+    super();
+
+    this.annotations = new Annotation();
+
+    this.scene = new THREE.Scene();
+    this.sceneBG = new THREE.Scene();
+    this.scenePointCloud = new THREE.Scene();
+
+    this.cameraP = new THREE.PerspectiveCamera(this.fov, 1, 0.1, 1000 * 1000);
+    this.cameraO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000 * 1000);
+    this.cameraVR = new THREE.PerspectiveCamera();
+    this.cameraBG = new THREE.Camera();
+    this.cameraScreenSpace = new THREE.OrthographicCamera(
+      -1,
+      1,
+      1,
+      -1,
+      0.1,
+      10
+    );
+    this.cameraMode = CameraMode.PERSPECTIVE;
+    this.overrideCamera = null;
+    this.pointclouds = [];
+
+    this.measurements = [];
+    this.profiles = [];
+    this.volumes = [];
+    this.polygonClipVolumes = [];
+    this.cameraAnimations = [];
+    this.orientedImages = [];
+    this.images360 = [];
+    this.geopackages = [];
+
+    this.fpControls = null;
+    this.orbitControls = null;
+    this.earthControls = null;
+    this.geoControls = null;
+    this.deviceControls = null;
+    this.inputHandler = null;
+
+    this.view = new View();
+
+    this.directionalLight = null;
+
+    this.initialize();
+  }
+
+  estimateHeightAt(position) {
+    let height = null;
+    let fromSpacing = Infinity;
+
+    for (let pointcloud of this.pointclouds) {
+      if (pointcloud.root.geometryNode === undefined) {
+        continue;
+      }
+
+      let pHeight = null;
+      let pFromSpacing = Infinity;
+
+      let lpos = position.clone().sub(pointcloud.position);
+      lpos.z = 0;
+      let ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));
+
+      let stack = [pointcloud.root];
+      while (stack.length > 0) {
+        let node = stack.pop();
+        let box = node.getBoundingBox();
+
+        let inside = ray.intersectBox(box);
+
+        if (!inside) {
+          continue;
+        }
+
+        let h =
+          node.geometryNode.mean.z +
+          pointcloud.position.z +
+          node.geometryNode.boundingBox.min.z;
+
+        if (node.geometryNode.spacing <= pFromSpacing) {
+          pHeight = h;
+          pFromSpacing = node.geometryNode.spacing;
+        }
+
+        for (let index of Object.keys(node.children)) {
+          let child = node.children[index];
+          if (child.geometryNode) {
+            stack.push(node.children[index]);
+          }
+        }
+      }
+
+      if (height === null || pFromSpacing < fromSpacing) {
+        height = pHeight;
+        fromSpacing = pFromSpacing;
+      }
+    }
+
+    return height;
+  }
+
+  getBoundingBox(pointclouds = this.pointclouds) {
+    let box = new THREE.Box3();
+
+    this.scenePointCloud.updateMatrixWorld(true);
+    this.referenceFrame.updateMatrixWorld(true);
+
+    for (let pointcloud of pointclouds) {
+      pointcloud.updateMatrixWorld(true);
+
+      let pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox
+        ? pointcloud.pcoGeometry.tightBoundingBox
+        : pointcloud.boundingBox;
+      let boxWorld = Utils.computeTransformedBoundingBox(
+        pointcloudBox,
+        pointcloud.matrixWorld
+      );
+      box.union(boxWorld);
+    }
+
+    return box;
+  }
+
+  addPointCloud(pointcloud) {
+    this.pointclouds.push(pointcloud);
+    this.scenePointCloud.add(pointcloud);
+
+    this.dispatchEvent({
+      type: "pointcloud_added",
+      pointcloud: pointcloud,
+    });
+  }
+
+  addVolume(volume) {
+    this.volumes.push(volume);
+    this.dispatchEvent({
+      type: "volume_added",
+      scene: this,
+      volume: volume,
+    });
+  }
+
+  addOrientedImages(images) {
+    this.orientedImages.push(images);
+    this.scene.add(images.node);
+
+    this.dispatchEvent({
+      type: "oriented_images_added",
+      scene: this,
+      images: images,
+    });
+  }
+
+  removeOrientedImages(images) {
+    let index = this.orientedImages.indexOf(images);
+    if (index > -1) {
+      this.orientedImages.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "oriented_images_removed",
+        scene: this,
+        images: images,
+      });
+    }
+  }
+
+  add360Images(images) {
+    this.images360.push(images);
+    this.scene.add(images.node);
+
+    this.dispatchEvent({
+      type: "360_images_added",
+      scene: this,
+      images: images,
+    });
+  }
+
+  remove360Images(images) {
+    let index = this.images360.indexOf(images);
+    if (index > -1) {
+      this.images360.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "360_images_removed",
+        scene: this,
+        images: images,
+      });
+    }
+  }
+
+  addGeopackage(geopackage) {
+    this.geopackages.push(geopackage);
+    this.scene.add(geopackage.node);
+
+    this.dispatchEvent({
+      type: "geopackage_added",
+      scene: this,
+      geopackage: geopackage,
+    });
+  }
+
+  removeGeopackage(geopackage) {
+    let index = this.geopackages.indexOf(geopackage);
+    if (index > -1) {
+      this.geopackages.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "geopackage_removed",
+        scene: this,
+        geopackage: geopackage,
+      });
+    }
+  }
+
+  removeVolume(volume) {
+    let index = this.volumes.indexOf(volume);
+    if (index > -1) {
+      this.volumes.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "volume_removed",
+        scene: this,
+        volume: volume,
+      });
+    }
+  }
+
+  addCameraAnimation(animation) {
+    this.cameraAnimations.push(animation);
+    this.dispatchEvent({
+      type: "camera_animation_added",
+      scene: this,
+      animation: animation,
+    });
+  }
+
+  removeCameraAnimation(animation) {
+    let index = this.cameraAnimations.indexOf(volume);
+    if (index > -1) {
+      this.cameraAnimations.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "camera_animation_removed",
+        scene: this,
+        animation: animation,
+      });
+    }
+  }
+
+  addPolygonClipVolume(volume) {
+    this.polygonClipVolumes.push(volume);
+    this.dispatchEvent({
+      type: "polygon_clip_volume_added",
+      scene: this,
+      volume: volume,
+    });
+  }
+
+  removePolygonClipVolume(volume) {
+    let index = this.polygonClipVolumes.indexOf(volume);
+    if (index > -1) {
+      this.polygonClipVolumes.splice(index, 1);
+      this.dispatchEvent({
+        type: "polygon_clip_volume_removed",
+        scene: this,
+        volume: volume,
+      });
+    }
+  }
+
+  addMeasurement(measurement) {
+    measurement.lengthUnit = this.lengthUnit;
+    measurement.lengthUnitDisplay = this.lengthUnitDisplay;
+    this.measurements.push(measurement);
+    this.dispatchEvent({
+      type: "measurement_added",
+      scene: this,
+      measurement: measurement,
+    });
+  }
+
+  removeMeasurement(measurement) {
+    let index = this.measurements.indexOf(measurement);
+    if (index > -1) {
+      this.measurements.splice(index, 1);
+      this.dispatchEvent({
+        type: "measurement_removed",
+        scene: this,
+        measurement: measurement,
+      });
+    }
+  }
+
+  addProfile(profile) {
+    this.profiles.push(profile);
+    this.dispatchEvent({
+      type: "profile_added",
+      scene: this,
+      profile: profile,
+    });
+  }
+
+  removeProfile(profile) {
+    let index = this.profiles.indexOf(profile);
+    if (index > -1) {
+      this.profiles.splice(index, 1);
+      this.dispatchEvent({
+        type: "profile_removed",
+        scene: this,
+        profile: profile,
+      });
+    }
+  }
+
+  removeAllMeasurements() {
+    while (this.measurements.length > 0) {
+      this.removeMeasurement(this.measurements[0]);
+    }
+
+    while (this.profiles.length > 0) {
+      this.removeProfile(this.profiles[0]);
+    }
+
+    while (this.volumes.length > 0) {
+      this.removeVolume(this.volumes[0]);
+    }
+  }
+
+  removeAllClipVolumes() {
+    let clipVolumes = this.volumes.filter((volume) => volume.clip === true);
+    for (let clipVolume of clipVolumes) {
+      this.removeVolume(clipVolume);
+    }
+
+    while (this.polygonClipVolumes.length > 0) {
+      this.removePolygonClipVolume(this.polygonClipVolumes[0]);
+    }
+  }
+
+  getActiveCamera() {
+    if (this.overrideCamera) {
+      return this.overrideCamera;
+    }
+
+    if (this.cameraMode === CameraMode.PERSPECTIVE) {
+      return this.cameraP;
+    } else if (this.cameraMode === CameraMode.ORTHOGRAPHIC) {
+      return this.cameraO;
+    } else if (this.cameraMode === CameraMode.VR) {
+      return this.cameraVR;
+    }
+
+    return null;
+  }
+
+  initialize() {
+    this.referenceFrame = new THREE.Object3D();
+    this.referenceFrame.matrixAutoUpdate = false;
+    this.scenePointCloud.add(this.referenceFrame);
+
+    this.cameraP.up.set(0, 0, 1);
+    this.cameraP.position.set(1000, 1000, 1000);
+    this.cameraO.up.set(0, 0, 1);
+    this.cameraO.position.set(1000, 1000, 1000);
+    //this.camera.rotation.y = -Math.PI / 4;
+    //this.camera.rotation.x = -Math.PI / 6;
+    this.cameraScreenSpace.lookAt(
+      new THREE.Vector3(0, 0, 0),
+      new THREE.Vector3(0, 0, -1),
+      new THREE.Vector3(0, 1, 0)
+    );
+
+    this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
+    this.directionalLight.position.set(10, 10, 10);
+    this.directionalLight.lookAt(new THREE.Vector3(0, 0, 0));
+    this.scenePointCloud.add(this.directionalLight);
+
+    let light = new THREE.AmbientLight(0x555555); // soft white light
+    this.scenePointCloud.add(light);
+
+    {
+      // background
+      let texture = Utils.createBackgroundTexture(512, 512);
+
+      texture.minFilter = texture.magFilter = THREE.NearestFilter;
+      texture.minFilter = texture.magFilter = THREE.LinearFilter;
+      let bg = new THREE.Mesh(
+        new THREE.PlaneBufferGeometry(2, 2, 1),
+        new THREE.MeshBasicMaterial({
+          map: texture,
+        })
+      );
+      bg.material.depthTest = false;
+      bg.material.depthWrite = false;
+      this.sceneBG.add(bg);
+    }
+
+    // { // lights
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(10, 10, 1);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(-10, 10, 1);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(0, -10, 20);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+    // }
+  }
+
+  addAnnotation(position, args = {}) {
+    if (position instanceof Array) {
+      args.position = new THREE.Vector3().fromArray(position);
+    } else if (position.x != null) {
+      args.position = position;
+    }
+    let annotation = new Annotation(args);
+    this.annotations.add(annotation);
+
+    return annotation;
+  }
+
+  getAnnotations() {
+    return this.annotations;
+  }
+
+  removeAnnotation(annotationToRemove) {
+    this.annotations.remove(annotationToRemove);
+  }
+}
diff --git a/src/viewer/map.js b/src/viewer/map.js
index 0979c607..314ac1e5 100644
--- a/src/viewer/map.js
+++ b/src/viewer/map.js
@@ -305,7 +305,7 @@ export class MapView{
 		};
 
 		this.on360ImagesAdded = e => {
-			this.addImages360(e.images);
+			// this.addImages360(e.images);
 		};
 
 		this.onAnnotationAdded = e => {
diff --git a/src/viewer/viewer.js b/src/viewer/viewer.js
index baf1fb1b..bb07592d 100644
--- a/src/viewer/viewer.js
+++ b/src/viewer/viewer.js
@@ -788,6 +788,7 @@ export class Viewer extends EventDispatcher{
 	};
 
 	zoomTo(node, factor, animationDuration = 0){
+		let changeEvent = new CustomEvent("camerachange");
 		let view = this.scene.view;
 
 		let camera = this.scene.cameraP.clone();
@@ -825,6 +826,7 @@ export class Viewer extends EventDispatcher{
 
 			tween.onUpdate(() => {
 				view.position.copy(pos);
+				document.dispatchEvent(changeEvent);
 			});
 
 			tween.start();
@@ -836,10 +838,12 @@ export class Viewer extends EventDispatcher{
 			tween.easing(easing);
 			tween.onUpdate(() => {
 				view.lookAt(target);
+				document.dispatchEvent(changeEvent);
 			});
 			tween.onComplete(() => {
 				view.lookAt(target);
 				this.dispatchEvent({type: 'focusing_finished', target: this});
+				document.dispatchEvent(changeEvent);
 			});
 
 			this.dispatchEvent({type: 'focusing_started', target: this});
@@ -1205,118 +1209,118 @@ export class Viewer extends EventDispatcher{
 		}
 
 		let viewer = this;
-		let sidebarContainer = $('#potree_sidebar_container');
-		sidebarContainer.load(new URL(Potree.scriptPath + '/sidebar.html').href, () => {
-			sidebarContainer.css('width', '300px');
-			sidebarContainer.css('height', '100%');
-
-			let imgMenuToggle = document.createElement('img');
-			imgMenuToggle.src = new URL(Potree.resourcePath + '/icons/menu_button.svg').href;
-			imgMenuToggle.onclick = this.toggleSidebar;
-			imgMenuToggle.classList.add('potree_menu_toggle');
-
-			let imgMapToggle = document.createElement('img');
-			imgMapToggle.src = new URL(Potree.resourcePath + '/icons/map_icon.png').href;
-			imgMapToggle.style.display = 'none';
-			imgMapToggle.onclick = e => { this.toggleMap(); };
-			imgMapToggle.id = 'potree_map_toggle';
+		// let sidebarContainer = $('#potree_sidebar_container');
+		// sidebarContainer.load(new URL(Potree.scriptPath + '/sidebar.html').href, () => {
+		// 	sidebarContainer.css('width', '300px');
+		// 	sidebarContainer.css('height', '100%');
+
+		// 	let imgMenuToggle = document.createElement('img');
+		// 	imgMenuToggle.src = new URL(Potree.resourcePath + '/icons/menu_button.svg').href;
+		// 	imgMenuToggle.onclick = this.toggleSidebar;
+		// 	imgMenuToggle.classList.add('potree_menu_toggle');
+
+		// 	let imgMapToggle = document.createElement('img');
+		// 	imgMapToggle.src = new URL(Potree.resourcePath + '/icons/map_icon.png').href;
+		// 	imgMapToggle.style.display = 'none';
+		// 	imgMapToggle.onclick = e => { this.toggleMap(); };
+		// 	imgMapToggle.id = 'potree_map_toggle';
 
 			
 
-			let elButtons = $("#potree_quick_buttons").get(0);
+		// 	let elButtons = $("#potree_quick_buttons").get(0);
 
-			elButtons.append(imgMenuToggle);
-			elButtons.append(imgMapToggle);
+		// 	elButtons.append(imgMenuToggle);
+		// 	elButtons.append(imgMapToggle);
 
 
-			VRButton.createButton(this.renderer).then(vrButton => {
+		// 	VRButton.createButton(this.renderer).then(vrButton => {
 
-				if(vrButton == null){
-					console.log("VR not supported or active.");
+		// 		if(vrButton == null){
+		// 			console.log("VR not supported or active.");
 
-					return;
-				}
+		// 			return;
+		// 		}
 
-				this.renderer.xr.enabled = true;
+		// 		this.renderer.xr.enabled = true;
 
-				let element = vrButton.element;
+		// 		let element = vrButton.element;
 
-				element.style.position = "";
-				element.style.bottom = "";
-				element.style.left = "";
-				element.style.margin = "4px";
-				element.style.fontSize = "100%";
-				element.style.width = "2.5em";
-				element.style.height = "2.5em";
-				element.style.padding = "0";
-				element.style.textShadow = "black 2px 2px 2px";
-				element.style.display = "block";
+		// 		element.style.position = "";
+		// 		element.style.bottom = "";
+		// 		element.style.left = "";
+		// 		element.style.margin = "4px";
+		// 		element.style.fontSize = "100%";
+		// 		element.style.width = "2.5em";
+		// 		element.style.height = "2.5em";
+		// 		element.style.padding = "0";
+		// 		element.style.textShadow = "black 2px 2px 2px";
+		// 		element.style.display = "block";
 
-				elButtons.append(element);
+		// 		elButtons.append(element);
 
-				vrButton.onStart(() => {
-					this.dispatchEvent({type: "vr_start"});
-				});
+		// 		vrButton.onStart(() => {
+		// 			this.dispatchEvent({type: "vr_start"});
+		// 		});
 
-				vrButton.onEnd(() => {
-					this.dispatchEvent({type: "vr_end"});
-				});
-			});
+		// 		vrButton.onEnd(() => {
+		// 			this.dispatchEvent({type: "vr_end"});
+		// 		});
+		// 	});
 
-			this.mapView = new MapView(this);
-			this.mapView.init();
-
-			i18n.init({
-				lng: 'en',
-				resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
-				preload: ['en', 'fr', 'de', 'jp', 'se', 'es', 'zh', 'it','ca'],
-				getAsync: true,
-				debug: false
-			}, function (t) {
-				// Start translation once everything is loaded
-				$('body').i18n();
-			});
+		// 	this.mapView = new MapView(this);
+		// 	this.mapView.init();
 
-			$(() => {
-				//initSidebar(this);
-				let sidebar = new Sidebar(this);
-				sidebar.init();
+		// 	i18n.init({
+		// 		lng: 'en',
+		// 		resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
+		// 		preload: ['en', 'fr', 'de', 'jp', 'se', 'es'],
+		// 		getAsync: true,
+		// 		debug: false
+		// 	}, function (t) {
+		// 		// Start translation once everything is loaded
+		// 		$('body').i18n();
+		// 	});
 
-				this.sidebar = sidebar;
+		// 	$(() => {
+		// 		//initSidebar(this);
+		// 		let sidebar = new Sidebar(this);
+		// 		sidebar.init();
 
-				//if (callback) {
-				//	$(callback);
-				//}
+		// 		this.sidebar = sidebar;
 
-				let elProfile = $('<div>').load(new URL(Potree.scriptPath + '/profile.html').href, () => {
-					$(document.body).append(elProfile.children());
-					this.profileWindow = new ProfileWindow(this);
-					this.profileWindowController = new ProfileWindowController(this);
+		// 		//if (callback) {
+		// 		//	$(callback);
+		// 		//}
 
-					$('#profile_window').draggable({
-						handle: $('#profile_titlebar'),
-						containment: $(document.body)
-					});
-					$('#profile_window').resizable({
-						containment: $(document.body),
-						handles: 'n, e, s, w'
-					});
+		// 		let elProfile = $('<div>').load(new URL(Potree.scriptPath + '/profile.html').href, () => {
+		// 			$(document.body).append(elProfile.children());
+		// 			this.profileWindow = new ProfileWindow(this);
+		// 			this.profileWindowController = new ProfileWindowController(this);
+
+		// 			$('#profile_window').draggable({
+		// 				handle: $('#profile_titlebar'),
+		// 				containment: $(document.body)
+		// 			});
+		// 			$('#profile_window').resizable({
+		// 				containment: $(document.body),
+		// 				handles: 'n, e, s, w'
+		// 			});
 
-					$(() => {
+		// 			$(() => {
 						this.guiLoaded = true;
 						for(let task of this.guiLoadTasks){
 							task();
 						}
 
-					});
-				});
+		// 			});
+		// 		});
 
 				
 
-			});
+		// 	});
 
 			
-		});
+		// });
 
 		return this.promiseGuiLoaded();
 	}
@@ -1349,14 +1353,14 @@ export class Viewer extends EventDispatcher{
 
 				const file = item.getAsFile();
 
-				const isJson5 = file.name.toLowerCase().endsWith(".json5");
+				const isJson = file.name.toLowerCase().endsWith(".json");
 				const isGeoPackage = file.name.toLowerCase().endsWith(".gpkg");
 
-				if(isJson5){
+				if(isJson){
 					try{
 
 						const text = await file.text();
-						const json = JSON5.parse(text);
+						const json = JSON.parse(text);
 
 						if(json.type === "Potree"){
 							Potree.loadProject(viewer, json);
-- 
2.38.1.windows.1


From 08c0fbff3c3ffae93ac75c328506e9ce3465b316 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 28 Jun 2023 16:40:38 +0530
Subject: [PATCH 04/13] ring geometry added to the potree and pitch correction
 also done

---
 src/modules/Images360/Images360.js           | 672 ++++++++++---------
 src/modules/OrientedImages/OrientedImages.js |  21 +-
 src/navigation/OrbitControls.js              |   9 +
 3 files changed, 390 insertions(+), 312 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 669de80b..0db1c26d 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -1,305 +1,373 @@
+
 import * as THREE from "../../../libs/three.js/build/three.module.js";
 import { EventDispatcher } from "../../EventDispatcher.js";
+class Image360{
+
+	constructor(file, thumbnail, longitude, latitude, altitude, course, pitch, roll){
+		this.file = file;
+		this.thumbnail = thumbnail;
+		this.longitude = longitude;
+		this.latitude = latitude;
+		this.altitude = altitude;
+		this.course = course;
+		this.pitch = pitch;
+		this.roll = roll;
+		this.mesh = null;
+	}
+};
+
+export class Images360 extends EventDispatcher{
+
+	constructor(viewer){
+		super();
+
+		this.viewer = viewer;
+
+		this.selectingEnabled = true;
+
+		this.images = [];
+		this.node = new THREE.Object3D();
+
+		this.sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 128, 128), new THREE.MeshBasicMaterial({side: THREE.BackSide}));
+		this.sphere.visible = false;
+		this.sphere.scale.set(-1000, 1000, 1000);
+		this.focus = this.focus.bind(this);
+		this.unfocus = this.unfocus.bind(this);
+		this.node.add(this.sphere);
+		this._visible = true;
+		this.focusedImage = null;
+		this.currentlyHovered = null;
+		this.previousView = {
+			controls: null,
+			position: null,
+			target: null,
+		};
+		this.raycaster = new THREE.Raycaster();
+		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
+		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
+		
+		viewer.addEventListener("update", () => {
+			this.update(viewer);
+		});
+		viewer.inputHandler.addInputListener(this);
+
+		this.addEventListener("mousedown", () => {
+			if(this.currentlyHovered && this.currentlyHovered.image360){
+				this.focus(this.currentlyHovered.image360);
+			}
+		});
+		this.addEventListener("touchend", () => {
+			if(this.currentlyHovered && this.currentlyHovered.image360){
+				this.focus(this.currentlyHovered.image360);
+			}
+		});
+	};
+
+	set visible(visible){
+		if(this._visible === visible){
+			return;
+		}
+
+
+		for(const image of this.images){
+			image.mesh.visible = visible && (this.focusedImage == null);
+		}
+
+		this.sphere.visible = visible && (this.focusedImage != null);
+		this._visible = visible;
+		this.dispatchEvent({
+			type: "visibility_changed",
+			images: this,
+		});
+	}
+
+	get visible(){
+		return this._visible;
+	}
+
+	focus(image360, sendEvent = true, inTarget = null){
+		if(this.focusedImage !== null){
+			this.unfocus();
+		}
+		this.viewer.setEDLOpacity(0);
+		if (sendEvent) {
+			const event = new CustomEvent("panoLoad", {
+				detail: {
+					viewer: this.viewer.canvasId,
+					image: image360
+				}
+			});
+			document.dispatchEvent(event);
+		}
+
+		this.previousView = {
+			controls: this.viewer.controls,
+			position: this.viewer.scene.view.position.clone(),
+			target: this.viewer.scene.view.getPivot(),
+		};
+		this.viewer.setControls(this.viewer.orbitControls);
+		this.viewer.orbitControls.doubleClockZoomEnabled = false;
+		let index = this.images.findIndex( element => {
+		if (element.file === image360.file) {
+		return true;
+		}
+		});
+		
+		for(let image of this.images){
+			
+			image.mesh.visible = false;
+		}
+		
+		if(index != 0)
+		{
+
+			let i = index - 1
+			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+			let dist = current.distanceTo(next)
+			while(dist < 0.5 && i > 0) {
+				i--
+				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+				dist = current.distanceTo(next)
+			}
+			this.images[i].mesh.visible = true
+			
+		}
+			let i = index + 1
+			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+			let dist = current.distanceTo(next)
+			while(dist < 0.5) {
+				i++
+				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+				dist = current.distanceTo(next)
+			}
+			this.images[i].mesh.visible = true
+		
+		this.selectingEnabled = true;
+		this.sphere.visible = false;
+		this.load(image360).then( () => {
+			this.sphere.visible = true;
+			this.sphere.material.map = image360.texture;
+			this.sphere.material.needsUpdate = true;
+		});
+			let {course, pitch, roll} = image360;
+			this.sphere.rotation.set(
+			THREE.Math.degToRad(course),
+			THREE.Math.degToRad(pitch),
+			THREE.Math.degToRad(roll),
+			"XYZ"
+		);
+		this.sphere.position.set(...image360.position);
+		let target = new THREE.Vector3(...image360.position);
+		let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
+		let move = dir.multiplyScalar(0.000001);
+		let newCamPos = target.clone().sub(move);
+		this.viewer.scene.view.setView(
+			newCamPos, 
+			target,
+			500,
+			() => {
+				if (inTarget && inTarget.pitch) {
+					this.viewer.scene.view.pitch = inTarget.pitch
+					this.viewer.scene.view.yaw = inTarget.yaw
+				}
+			}
+		);
+
+		this.focusedImage = image360;
+
+	}
+
+	unfocus(sendEvent = true){
+		this.selectingEnabled = true;
+		this.viewer.setEDLOpacity(1);
+		let image = this.focusedImage;
+		if(image === null){
+			return;
+		}
+		this.sphere.material.map = null;
+		this.sphere.material.needsUpdate = true;
+		this.sphere.visible = false;
+		this.sphere.position.set(this.sphere.position - [...this.images[0].position]);
+
+		let pos = this.viewer.scene.view.position;
+		let target = this.viewer.scene.view.getPivot();
+		let dir = target.clone().sub(pos).normalize();
+		let move = dir.multiplyScalar(10);
+		let newCamPos = target.clone().sub(move);
+
+		this.viewer.orbitControls.doubleClockZoomEnabled = true;
+		this.viewer.setControls(this.previousView.controls);
+		this.focusedImage = null;
+		
+		if (sendEvent) {
+			const event = new CustomEvent("panoUnload", {
+				detail: {
+					viewer: this.viewer.canvasId
+				}
+			});
+			document.dispatchEvent(event);
+		}
+
+	}
+
+	load(image360){
+		let resolved = false;
+		return new Promise(resolve => {
+			if (image360.texture) {
+				resolve(null);
+			} else {
+				new THREE.TextureLoader().load(image360.thumbnail,
+					texture => {
+							//var sphereMaterial = new MeshBasicMaterial({ map: texture, side: DoubleSide });
+                            //image360.texture = sphereMaterial;
+							image360.texture = texture;
+							resolved = true;
+							resolve(null);
+							loadOrgImage.bind(this)();
+						},
+					undefined,
+					err => {
+						loadOrgImage.bind(this)();
+					});
+				let loadOrgImage = function () {
+
+					new THREE.TextureLoader().load(image360.file,
+						texture => {
+								//var sphereMaterial = new MeshBasicMaterial({ map: texture, side: DoubleSide });
+                            	//image360.texture = sphereMaterial;
+								image360.texture = texture;
+								this.sphere.visible = true;
+								this.sphere.material.map = image360.texture;
+								this.sphere.material.needsUpdate = true;
+								if (!resolved) {
+									resolve(null);
+								}
+							});
+				}
+
+			}
+		});
+
+	}
+
+	handleHovering(){
+		let mouse = this.viewer.inputHandler.mouse;
+		let camera = this.viewer.scene.getActiveCamera();
+		let domElement = this.viewer.renderer.domElement;
+		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
+		this.raycaster.ray.copy(ray);
+		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
+			return image.mesh}));
+		if(intersections.length === 0){
+			return;
+		}
+		let intersection = intersections[0];
+		if(intersection.object.image360.mesh.visible===true)
+		{
+		this.currentlyHovered = intersection.object;
+		this.currentlyHovered.material = this.hoverMaterial;
+		}
+		
+	}
+
+	update(){
+
+		let {viewer} = this;
+
+		if(this.currentlyHovered){
+			this.currentlyHovered.material = this.sm;
+			this.currentlyHovered = null;
+		}
+
+		if(this.selectingEnabled){
+			this.handleHovering();
+		}
+
+	}
+};
+
+
+export class Images360Loader{
+
+	static async load(url, imgsUrl, viewer, tm_data, params = {}){
+
+		if(!params.transform){
+			params.transform = {
+				forward: a => a,
+			};
+		}
+
+		let tmatrix, toffset;
+		
+		tmatrix = tm_data.tm;
+		toffset = tm_data.offset;
+		
+		let response = await fetch(url);
+		let text = await response.text();
+		let imgData = JSON.parse(text);
+
+		let images360 = new Images360(viewer);
+
+		Object.keys(imgData).forEach(imgName => {
+			let raw_position = imgData[imgName].position;
+			let rotation = imgData[imgName].rotation;
+			
+			const pos = new THREE.Vector4(raw_position[0], raw_position[1], raw_position[2], 1);
+			pos.applyMatrix4(tmatrix);
+			const long = parseFloat(pos.x - toffset[0]);
+			const lat = parseFloat(pos.y - toffset[1]);
+			const alt = parseFloat((pos.z - toffset[2]));
+			const course = parseFloat(rotation[0]);
+			const pitch = parseFloat(rotation[1]);
+			const roll = parseFloat(rotation[2]);
+
+			let file = `${imgsUrl}/${imgName}`;
+			let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
+			let image360 = new Image360(file, thumbnail, long, lat, alt, course, pitch, roll);
+
+			let position = [long, lat, alt];
+			image360.position = position;
+
+			images360.images.push(image360);
+		});
+
+		images360.images.sort(function (a, b) {
+			const getFileNumber = (file) => {
+				const numberPattern = /\d+/g;
+				const numbers = file.match(numberPattern);
+				if (numbers) {
+				return numbers.map((num) => num.padStart(10, '0')).join('');
+				}
+				return file;
+			};
+
+			const fileANumber = getFileNumber(a.file);
+			const fileBNumber = getFileNumber(b.file);
+			return fileANumber.localeCompare(fileBNumber);
+		});
+		
+		Images360Loader.createSceneNodes(images360, params.transform);
+
+		return images360;
+
+	}
+
+	static createSceneNodes(images360){
+
+		for(let image360 of images360.images){
+			let {longitude, latitude, altitude} = image360;
+			let mesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+			mesh.position.set(longitude, latitude, altitude - 2.0);
+			mesh.scale.set(1, 1, 1);
+			mesh.material.transparent = true;
+			mesh.material.opacity = 0.75;
+			mesh.image360 = image360;
+			images360.node.add(mesh);
+			image360.mesh = mesh;
+		}
+	}
+};
+
 
-class Image360 {
-  constructor(
-    file,
-    thumbnail,
-    longitude,
-    latitude,
-    altitude,
-    course,
-    pitch,
-    roll
-  ) {
-    this.file = file;
-    this.thumbnail = thumbnail;
-    this.longitude = longitude;
-    this.latitude = latitude;
-    this.altitude = altitude;
-    this.course = course;
-    this.pitch = pitch;
-    this.roll = roll;
-  }
-}
-
-export class Images360 extends EventDispatcher {
-  constructor(viewer) {
-    super();
-
-    this.viewer = viewer;
-
-    this.selectingEnabled = true;
-
-    this.images = [];
-    this.node = new THREE.Object3D();
-
-    this.sphere = new THREE.Mesh(
-      new THREE.SphereGeometry(1, 128, 128),
-      new THREE.MeshBasicMaterial({ side: THREE.BackSide })
-    );
-    this.sphere.visible = false;
-    this.sphere.scale.set(-1000, 1000, 1000);
-
-    this.focus = this.focus.bind(this);
-    this.unfocus = this.unfocus.bind(this);
-    this.node.add(this.sphere);
-    this._visible = true;
-
-    this.focusedImage = null;
-    this.currentlyHovered = null;
-    this.previousView = {
-      controls: null,
-      position: null,
-      target: null,
-    };
-    this.raycaster = new THREE.Raycaster();
-    this.hoverMaterial = new THREE.MeshBasicMaterial({
-      side: THREE.BackSide,
-      color: 0xff0000,
-    });
-    this.sm = new THREE.MeshBasicMaterial({ side: THREE.BackSide });
-
-    // viewer.addEventListener("update", () => {
-    //   this.update(viewer);
-    // });
-    viewer.inputHandler.addInputListener(this);
-
-    this.addEventListener("mousedown", () => {
-      if (this.currentlyHovered && this.currentlyHovered.image360) {
-        this.focus(this.currentlyHovered.image360);
-      }
-    });
-  }
-
-  set visible(visible) {
-    if (this._visible === visible) {
-      return;
-    }
-    this.sphere.visible = visible && this.focusedImage != null;
-    this._visible = visible;
-    this.dispatchEvent({
-      type: "visibility_changed",
-      images: this,
-    });
-  }
-
-  get visible() {
-    return this._visible;
-  }
-
-  focus(image360, sendEvent = true, inTarget = null) {
-    if (this.focusedImage !== null) {
-      this.unfocus();
-    }
-    this.viewer.setEDLOpacity(0);
-    if (sendEvent) {
-      const event = new CustomEvent("panoLoad", {
-        detail: {
-          viewer: this.viewer.canvasId,
-          image: image360,
-        },
-      });
-      document.dispatchEvent(event);
-    }
-
-    this.previousView = {
-      controls: this.viewer.controls,
-      position: this.viewer.scene.view.position.clone(),
-      target: this.viewer.scene.view.getPivot(),
-    };
-
-    this.viewer.setControls(this.viewer.orbitControls);
-    this.viewer.orbitControls.doubleClockZoomEnabled = false;
-
-    this.selectingEnabled = false;
-
-    this.sphere.visible = false;
-
-    this.load(image360).then(() => {
-      this.sphere.visible = true;
-      this.sphere.material.map = image360.texture;
-      this.sphere.material.needsUpdate = true;
-    });
-
-    // orientation
-    let { course, pitch, roll } = image360;
-
-    this.sphere.rotation.set(
-      THREE.Math.degToRad(course),
-      THREE.Math.degToRad(pitch),
-      THREE.Math.degToRad(roll),
-      "XYZ"
-    );
-
-    this.sphere.position.set(...image360.position);
-
-    let target = new THREE.Vector3(...image360.position);
-    let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
-    let move = dir.multiplyScalar(0.000001);
-    let newCamPos = target.clone().sub(move);
-
-    this.viewer.scene.view.setView(newCamPos, target, 500, () => {
-      if (inTarget && inTarget.pitch) {
-        this.viewer.scene.view.pitch = inTarget.pitch;
-        this.viewer.scene.view.yaw = inTarget.yaw;
-      }
-    });
-
-    this.focusedImage = image360;
-  }
-
-  unfocus(sendEvent = true) {
-    this.selectingEnabled = true;
-    this.viewer.setEDLOpacity(1);
-
-    let image = this.focusedImage;
-
-    if (image === null) {
-      return;
-    }
-    delete image.texture;
-    this.sphere.material.map = null;
-    this.sphere.material.needsUpdate = true;
-    this.sphere.visible = false;
-    this.viewer.orbitControls.doubleClockZoomEnabled = true;
-    this.viewer.setControls(this.previousView.controls);
-
-    this.focusedImage = null;
-
-    if (sendEvent) {
-      const event = new CustomEvent("panoUnload", {
-        detail: {
-          viewer: this.viewer.canvasId,
-        },
-      });
-      document.dispatchEvent(event);
-    }
-  }
-
-  load(image360) {
-    let resolved = false;
-    return new Promise((resolve) => {
-      if (image360.texture) {
-        resolve(null);
-      } else {
-        new THREE.TextureLoader().load(
-          image360.thumbnail,
-          (texture) => {
-            image360.texture = texture;
-            resolved = true;
-            resolve(null);
-            loadOrgImage.bind(this)();
-          },
-          undefined,
-          (err) => {
-            loadOrgImage.bind(this)();
-          }
-        );
-        let loadOrgImage = function () {
-          new THREE.TextureLoader().load(image360.file, (texture) => {
-            image360.texture = texture;
-            this.sphere.visible = true;
-            this.sphere.material.map = image360.texture;
-            this.sphere.material.needsUpdate = true;
-            if (!resolved) {
-              resolve(null);
-            }
-            // }
-          });
-        };
-      }
-    });
-  }
-
-  //   handleHovering() {
-  //     let mouse = this.viewer.inputHandler.mouse;
-  //     let camera = this.viewer.scene.getActiveCamera();
-  //     let domElement = this.viewer.renderer.domElement;
-
-  //     let ray = Potree.Utils.mouseToRay(
-  //       mouse,
-  //       camera,
-  //       domElement.clientWidth,
-  //       domElement.clientHeight
-  //     );
-
-  //     this.raycaster.ray.copy(ray);
-  //     let intersections = this.raycaster.intersectObjects(this.node.children);
-
-  //     if (intersections.length === 0) {
-  //       return;
-  //     }
-
-  //     let intersection = intersections[0];
-  //     this.currentlyHovered = intersection.object;
-  //     this.currentlyHovered.material = this.hoverMaterial;
-  //   }
-
-  //   update() {
-  //     let { viewer } = this;
-
-  //     if (this.currentlyHovered) {
-  //       this.currentlyHovered.material = this.sm;
-  //       this.currentlyHovered = null;
-  //     }
-
-  //     if (this.selectingEnabled) {
-  //       // this.handleHovering();
-  //     }
-  //   }
-}
-
-export class Images360Loader {
-  static async load(url, imgsUrl, viewer, tm_data) {
-    let tmatrix, toffset;
-
-    tmatrix = tm_data.tm;
-    toffset = tm_data.offset;
-
-    let response = await fetch(url);
-    let text = await response.text();
-    let imgData = JSON.parse(text);
-
-    let images360 = new Images360(viewer);
-    Object.keys(imgData).forEach((imgName) => {
-      let raw_position = imgData[imgName].position;
-      let rotation = imgData[imgName].rotation;
-
-      const pos = new THREE.Vector4(
-        raw_position[0],
-        raw_position[1],
-        raw_position[2],
-        1
-      );
-      pos.applyMatrix4(tmatrix);
-
-      const long = parseFloat(pos.x - toffset[0]);
-      const lat = parseFloat(pos.y - toffset[1]);
-      const alt = parseFloat(pos.z - toffset[2]);
-      const course = parseFloat(rotation[0]);
-      const pitch = parseFloat(rotation[1]);
-      const roll = parseFloat(rotation[2]);
-
-      let file = `${imgsUrl}/${imgName}`;
-      let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
-      let image360 = new Image360(
-        file,
-        thumbnail,
-        long,
-        lat,
-        alt,
-        course,
-        pitch,
-        roll
-      );
-
-      let position = [long, lat, alt];
-      image360.position = position;
-
-      images360.images.push(image360);
-    });
-
-    return images360;
-  }
-}
diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
index 0d95c86e..4da9cd47 100644
--- a/src/modules/OrientedImages/OrientedImages.js
+++ b/src/modules/OrientedImages/OrientedImages.js
@@ -390,15 +390,7 @@ export class OrientedImageLoader {
     const moveToImage = async (image, sendEvent = true) => {
       viewer.controls.enabled = false;
 
-      if (sendEvent) {
-        const event = new CustomEvent("imageLoad", {
-          detail: {
-            viewer: viewer.canvasId,
-            image,
-          },
-        });
-        document.dispatchEvent(event);
-      }
+      
 
       const mesh = image.mesh;
       const target = image;
@@ -407,7 +399,16 @@ export class OrientedImageLoader {
       const newCamTarget = mesh.position.clone();
 
       viewer.scene.view.setView(newCamPos, newCamTarget);
-
+	if (sendEvent) {
+        const event = new CustomEvent("imageLoad", {
+          detail: {
+            viewer: viewer.canvasId,
+            image,
+          },
+        });
+        document.dispatchEvent(event);
+      }
+	  
       function loadImageTexture(path) {
         return new Promise((resolve, reject) => {
           new THREE.TextureLoader().load(path, (texture) => {
diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
index 1d21da93..fed504a3 100644
--- a/src/navigation/OrbitControls.js
+++ b/src/navigation/OrbitControls.js
@@ -276,6 +276,15 @@ export class OrbitControls extends EventDispatcher {
       yaw -= progression * this.yawDelta;
       pitch -= progression * this.pitchDelta;
 
+		if(pitch < -1 * 0.3)
+		{
+			pitch= -1 * 0.3
+		}
+		else if(pitch > 1.3)
+		{
+			pitch = 1.3
+		}
+		
       view.yaw = yaw;
       view.pitch = pitch;
 
-- 
2.38.1.windows.1


From a3ca317809eaa9c81648e53b982ff673e8b56fd9 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 28 Jun 2023 17:41:49 +0530
Subject: [PATCH 05/13] conditions is added for 360 image   rings visibility

---
 src/modules/Images360/Images360.js | 24 +++++++++++++++++++++---
 1 file changed, 21 insertions(+), 3 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 0db1c26d..c7d5403b 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -107,7 +107,14 @@ export class Images360 extends EventDispatcher{
 		};
 		this.viewer.setControls(this.viewer.orbitControls);
 		this.viewer.orbitControls.doubleClockZoomEnabled = false;
-		let index = this.images.findIndex( element => {
+		if (
+        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+          navigator.userAgent
+        ) ||
+        (window.innerWidth <= 768))
+        {
+          
+        let index = this.images.findIndex( element => {
 		if (element.file === image360.file) {
 		return true;
 		}
@@ -145,6 +152,11 @@ export class Images360 extends EventDispatcher{
 			this.images[i].mesh.visible = true
 		
 		this.selectingEnabled = true;
+		}
+		else
+		{
+			this.selectingEnabled = false;
+		}
 		this.sphere.visible = false;
 		this.load(image360).then( () => {
 			this.sphere.visible = true;
@@ -347,9 +359,15 @@ export class Images360Loader{
 			const fileBNumber = getFileNumber(b.file);
 			return fileANumber.localeCompare(fileBNumber);
 		});
-		
-		Images360Loader.createSceneNodes(images360, params.transform);
 
+		if (
+        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+          navigator.userAgent
+        ) ||
+        (window.innerWidth <= 768))
+        {
+           Images360Loader.createSceneNodes(images360, params.transform);
+        }
 		return images360;
 
 	}
-- 
2.38.1.windows.1


From 1356855bfa2406c97415fa9a0a9be68569c2ae14 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 12 Jul 2023 17:37:28 +0530
Subject: [PATCH 06/13] code chnages

---
 src/modules/Images360/Images360.js | 50 ++++++++++++++----------------
 src/navigation/OrbitControls.js    | 19 +++++-------
 2 files changed, 32 insertions(+), 37 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index c7d5403b..63e92c3d 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -54,11 +54,25 @@ export class Images360 extends EventDispatcher{
 		this.addEventListener("mousedown", () => {
 			if(this.currentlyHovered && this.currentlyHovered.image360){
 				this.focus(this.currentlyHovered.image360);
+				const event = new CustomEvent("onRingClick", {
+                    detail: {
+                        viewer: this.viewer.canvasId,
+                        image: this.currentlyHovered.image360
+                    }
+                });
+                document.dispatchEvent(event);
 			}
 		});
 		this.addEventListener("touchend", () => {
 			if(this.currentlyHovered && this.currentlyHovered.image360){
 				this.focus(this.currentlyHovered.image360);
+				const event = new CustomEvent("onRingClick", {
+                    detail: {
+                        viewer: this.viewer.canvasId,
+                        image: this.currentlyHovered.image360
+                    }
+                });
+                document.dispatchEvent(event);
 			}
 		});
 	};
@@ -106,15 +120,9 @@ export class Images360 extends EventDispatcher{
 			target: this.viewer.scene.view.getPivot(),
 		};
 		this.viewer.setControls(this.viewer.orbitControls);
+		this.viewer.orbitControls.isInterior = true;
 		this.viewer.orbitControls.doubleClockZoomEnabled = false;
-		if (
-        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
-          navigator.userAgent
-        ) ||
-        (window.innerWidth <= 768))
-        {
-          
-        let index = this.images.findIndex( element => {
+		let index = this.images.findIndex( element => {
 		if (element.file === image360.file) {
 		return true;
 		}
@@ -132,31 +140,27 @@ export class Images360 extends EventDispatcher{
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 			let dist = current.distanceTo(next)
-			while(dist < 0.5 && i > 0) {
+			while(dist < 3 && i > -1) {
 				i--
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
-			this.images[i].mesh.visible = true
+			if(i>-1)this.images[i].mesh.visible = true
 			
 		}
 			let i = index + 1
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 			let dist = current.distanceTo(next)
-			while(dist < 0.5) {
+			while(dist < 3 && i<this.images.length) {
 				i++
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
-			this.images[i].mesh.visible = true
+			if(i<this.images.length)this.images[i].mesh.visible = true
 		
 		this.selectingEnabled = true;
-		}
-		else
-		{
-			this.selectingEnabled = false;
-		}
+		
 		this.sphere.visible = false;
 		this.load(image360).then( () => {
 			this.sphere.visible = true;
@@ -210,6 +214,7 @@ export class Images360 extends EventDispatcher{
 		let newCamPos = target.clone().sub(move);
 
 		this.viewer.orbitControls.doubleClockZoomEnabled = true;
+		this.viewer.orbitControls.isInterior = false;
 		this.viewer.setControls(this.previousView.controls);
 		this.focusedImage = null;
 		
@@ -360,15 +365,8 @@ export class Images360Loader{
 			return fileANumber.localeCompare(fileBNumber);
 		});
 
-		if (
-        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
-          navigator.userAgent
-        ) ||
-        (window.innerWidth <= 768))
-        {
-           Images360Loader.createSceneNodes(images360, params.transform);
-        }
-		return images360;
+		 Images360Loader.createSceneNodes(images360);
+			return images360;
 
 	}
 
diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
index fed504a3..2ed5150c 100644
--- a/src/navigation/OrbitControls.js
+++ b/src/navigation/OrbitControls.js
@@ -37,7 +37,7 @@ export class OrbitControls extends EventDispatcher {
     this.radiusDelta = 0;
 
     this.doubleClockZoomEnabled = true;
-
+	this.isInterior=false
     this.tweens = [];
 
     this.changeEvent = new CustomEvent("camerachange");
@@ -275,16 +275,13 @@ export class OrbitControls extends EventDispatcher {
 
       yaw -= progression * this.yawDelta;
       pitch -= progression * this.pitchDelta;
-
-		if(pitch < -1 * 0.3)
-		{
-			pitch= -1 * 0.3
-		}
-		else if(pitch > 1.3)
-		{
-			pitch = 1.3
-		}
-		
+	if (this.isInterior) {
+      if (pitch < -1 * 0.3) {
+        pitch = -1 * 0.3;
+      } else if (pitch > 1.3) {
+        pitch = 1.3;
+      }
+    }	
       view.yaw = yaw;
       view.pitch = pitch;
 
-- 
2.38.1.windows.1


From 0f859e01a5c5d2705aeca7a38887af66248dfe8f Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 12 Jul 2023 17:45:12 +0530
Subject: [PATCH 07/13] code changes

---
 examples/lion_las.html | 60 ++++++++++++------------------------------
 1 file changed, 17 insertions(+), 43 deletions(-)

diff --git a/examples/lion_las.html b/examples/lion_las.html
index fe233423..2df2bdb5 100644
--- a/examples/lion_las.html
+++ b/examples/lion_las.html
@@ -75,46 +75,7 @@
         $("#menu_appearance").next().show();
       });
 
-      function isMobileDevice() {
-        // Check for a specific mobile user agent string or screen size
-        // Modify this condition based on your requirements
-        console.log("fduihsdfju8iyshdfgyusifdhkjsdfhyuik", navigator.userAgent);
-        return (
-          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
-            navigator.userAgent
-          ) || window.innerWidth <= 768
-        );
-      }
-
-      // Execute code only for the mobile version
-      if (isMobileDevice()) {
-        // Your mobile-specific code here
-        console.log("Running on a mobile device");
-        viewer.setDescription(`<button id="myButton">Next Image</button> `);
-        var button = document.getElementById("myButton");
-        button.addEventListener("click", function () {
-          i++;
-          console.log("sdujksdn", i);
-          //   viewer.scene.orientedImages[0].moveToImage(
-          //     viewer.scene.orientedImages[0].images[i]
-          //   );
-          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
-          //removeAssets(viewer);
-        });
-      } else {
-        // Your web-specific code here
-        console.log("Running on the web", navigator.userAgent);
-      }
-      // Add a click event listener to the button
-      //   button.addEventListener("click", function () {
-      //     i++;
-      //     nextPanoImage(viewer);
-      //     // viewer.scene.orientedImages[0].moveToImage(
-      //     //   viewer.scene.orientedImages[0].images[i]
-      //     // );
-      //     //viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
-      //     //removeAssets(viewer);
-      //   });
+     
       let viewerMode = "image";
       // Sigeom
       Potree.loadPointCloud(
@@ -153,9 +114,22 @@
           let pcOffset = [0, 0, 0];
           pcMatrix = new THREE.Matrix4()
             .fromArray([
-              1.000465, 0.003179, 0.000021, -10232.804688, -0.003179, 1.000465,
-              0.000031, -231.655838, -0.000021, -0.000031, 1.00047, -1272.54834,
-              0.0, 0.0, 0.0, 1.0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
             ])
             .transpose();
           pointcloud.applyMatrix(pcMatrix);
-- 
2.38.1.windows.1


From abbb15298fad7c727b310c029fa3a8eb74eea7da Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Thu, 13 Jul 2023 12:55:30 +0530
Subject: [PATCH 08/13] Ring geometry modification for clicking all over the
 circle completed

---
 src/modules/Images360/Images360.js | 55 +++++++++++++++++++-----------
 1 file changed, 36 insertions(+), 19 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 63e92c3d..fcba8200 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -43,8 +43,7 @@ export class Images360 extends EventDispatcher{
 			target: null,
 		};
 		this.raycaster = new THREE.Raycaster();
-		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
-		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
+		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide});
 		
 		viewer.addEventListener("update", () => {
 			this.update(viewer);
@@ -84,7 +83,7 @@ export class Images360 extends EventDispatcher{
 
 
 		for(const image of this.images){
-			image.mesh.visible = visible && (this.focusedImage == null);
+			image.circleMesh.visible = visible && (this.focusedImage == null);
 		}
 
 		this.sphere.visible = visible && (this.focusedImage != null);
@@ -129,8 +128,9 @@ export class Images360 extends EventDispatcher{
 		});
 		
 		for(let image of this.images){
-			
-			image.mesh.visible = false;
+
+			image.circleMesh.visible = false;
+			image.ringMesh.visible=false
 		}
 		
 		if(index != 0)
@@ -145,7 +145,11 @@ export class Images360 extends EventDispatcher{
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
-			if(i>-1)this.images[i].mesh.visible = true
+			if(i>-1)
+			{
+			this.images[i].circleMesh.visible = true
+			this.images[i].ringMesh.visible = true	
+			}
 			
 		}
 			let i = index + 1
@@ -157,7 +161,11 @@ export class Images360 extends EventDispatcher{
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
-			if(i<this.images.length)this.images[i].mesh.visible = true
+			if(i<this.images.length)
+			{
+			this.images[i].circleMesh.visible = true
+			this.images[i].ringMesh.visible = true	
+			}
 		
 		this.selectingEnabled = true;
 		
@@ -276,12 +284,12 @@ export class Images360 extends EventDispatcher{
 		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
 		this.raycaster.ray.copy(ray);
 		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
-			return image.mesh}));
+			return image.circleMesh}));
 		if(intersections.length === 0){
 			return;
 		}
 		let intersection = intersections[0];
-		if(intersection.object.image360.mesh.visible===true)
+		if(intersection.object.image360.circleMesh.visible===true)
 		{
 		this.currentlyHovered = intersection.object;
 		this.currentlyHovered.material = this.hoverMaterial;
@@ -292,9 +300,8 @@ export class Images360 extends EventDispatcher{
 	update(){
 
 		let {viewer} = this;
-
 		if(this.currentlyHovered){
-			this.currentlyHovered.material = this.sm;
+			this.currentlyHovered.material = this.handleHovering;
 			this.currentlyHovered = null;
 		}
 
@@ -374,14 +381,24 @@ export class Images360Loader{
 
 		for(let image360 of images360.images){
 			let {longitude, latitude, altitude} = image360;
-			let mesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
-			mesh.position.set(longitude, latitude, altitude - 2.0);
-			mesh.scale.set(1, 1, 1);
-			mesh.material.transparent = true;
-			mesh.material.opacity = 0.75;
-			mesh.image360 = image360;
-			images360.node.add(mesh);
-			image360.mesh = mesh;
+			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+			ringMesh.position.set(longitude, latitude, altitude - 2.0);
+			ringMesh.scale.set(1, 1, 1);
+			ringMesh.material.transparent = true;
+			ringMesh.material.opacity = 0.75;
+			ringMesh.image360 = image360;
+			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( 1, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
+			circleMesh.position.set(longitude, latitude, altitude - 2.0);
+			circleMesh.scale.set(1, 1, 1);
+			circleMesh.material.transparent = true;
+			circleMesh.material.opacity = 0;
+			circleMesh.image360 = image360;
+			const group = new THREE.Group();
+			group.add( ringMesh );
+			group.add( circleMesh );
+			images360.node.add(group);
+			image360.circleMesh = circleMesh;
+			image360.ringMesh = ringMesh;
 		}
 	}
 };
-- 
2.38.1.windows.1


From 530510e78b7f780f4473097d2f0bd5d400278bf7 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Thu, 13 Jul 2023 15:52:58 +0530
Subject: [PATCH 09/13] ring color changing when hovering

---
 src/modules/Images360/Images360.js | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index fcba8200..a427a79c 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -43,8 +43,8 @@ export class Images360 extends EventDispatcher{
 			target: null,
 		};
 		this.raycaster = new THREE.Raycaster();
-		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide});
-		
+		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:''});
+		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
 		viewer.addEventListener("update", () => {
 			this.update(viewer);
 		});
@@ -291,7 +291,7 @@ export class Images360 extends EventDispatcher{
 		let intersection = intersections[0];
 		if(intersection.object.image360.circleMesh.visible===true)
 		{
-		this.currentlyHovered = intersection.object;
+		this.currentlyHovered = intersection.object.parent.children[0];
 		this.currentlyHovered.material = this.hoverMaterial;
 		}
 		
@@ -301,7 +301,7 @@ export class Images360 extends EventDispatcher{
 
 		let {viewer} = this;
 		if(this.currentlyHovered){
-			this.currentlyHovered.material = this.handleHovering;
+			this.currentlyHovered.material = this.sm;
 			this.currentlyHovered = null;
 		}
 
-- 
2.38.1.windows.1


From 93e974b0c17287945e48e0deac6a08334b8f066a Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Thu, 13 Jul 2023 17:13:25 +0530
Subject: [PATCH 10/13] ring geometry nameing convention changes

---
 src/modules/Images360/Images360.js | 42 ++++++++++++++----------------
 1 file changed, 20 insertions(+), 22 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index a427a79c..9eca6a46 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -12,7 +12,8 @@ class Image360{
 		this.course = course;
 		this.pitch = pitch;
 		this.roll = roll;
-		this.mesh = null;
+		this.ringGroup=null
+		this.visibleRings=[]
 	}
 };
 
@@ -27,7 +28,7 @@ export class Images360 extends EventDispatcher{
 
 		this.images = [];
 		this.node = new THREE.Object3D();
-
+		this.visibleRings=[]		
 		this.sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 128, 128), new THREE.MeshBasicMaterial({side: THREE.BackSide}));
 		this.sphere.visible = false;
 		this.sphere.scale.set(-1000, 1000, 1000);
@@ -83,7 +84,7 @@ export class Images360 extends EventDispatcher{
 
 
 		for(const image of this.images){
-			image.circleMesh.visible = visible && (this.focusedImage == null);
+			image.ringGroup.visible = visible && (this.focusedImage == null);
 		}
 
 		this.sphere.visible = visible && (this.focusedImage != null);
@@ -128,9 +129,7 @@ export class Images360 extends EventDispatcher{
 		});
 		
 		for(let image of this.images){
-
-			image.circleMesh.visible = false;
-			image.ringMesh.visible=false
+			image.ringGroup.visible=false
 		}
 		
 		if(index != 0)
@@ -140,15 +139,15 @@ export class Images360 extends EventDispatcher{
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 			let dist = current.distanceTo(next)
-			while(dist < 3 && i > -1) {
+			while(dist < 3 && i > 0) {
 				i--
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
 			if(i>-1)
 			{
-			this.images[i].circleMesh.visible = true
-			this.images[i].ringMesh.visible = true	
+			this.images[i].ringGroup.visible = true
+			this.visibleRings.push(this.images[i])
 			}
 			
 		}
@@ -163,8 +162,8 @@ export class Images360 extends EventDispatcher{
 			}
 			if(i<this.images.length)
 			{
-			this.images[i].circleMesh.visible = true
-			this.images[i].ringMesh.visible = true	
+			this.images[i].ringGroup.visible = true
+			this.visibleRings.push(this.images[i])	
 			}
 		
 		this.selectingEnabled = true;
@@ -283,13 +282,13 @@ export class Images360 extends EventDispatcher{
 		let domElement = this.viewer.renderer.domElement;
 		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
 		this.raycaster.ray.copy(ray);
-		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
-			return image.circleMesh}));
+		let intersections = this.raycaster.intersectObjects(this.visibleRings.map(image=>{
+			return image.ringGroup.children[1]}));
 		if(intersections.length === 0){
 			return;
 		}
 		let intersection = intersections[0];
-		if(intersection.object.image360.circleMesh.visible===true)
+		if(intersection.object.parent.visible===true)
 		{
 		this.currentlyHovered = intersection.object.parent.children[0];
 		this.currentlyHovered.material = this.hoverMaterial;
@@ -381,24 +380,23 @@ export class Images360Loader{
 
 		for(let image360 of images360.images){
 			let {longitude, latitude, altitude} = image360;
-			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.35, .5, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
 			ringMesh.position.set(longitude, latitude, altitude - 2.0);
 			ringMesh.scale.set(1, 1, 1);
 			ringMesh.material.transparent = true;
 			ringMesh.material.opacity = 0.75;
 			ringMesh.image360 = image360;
-			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( 1, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
+			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( .5, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
 			circleMesh.position.set(longitude, latitude, altitude - 2.0);
 			circleMesh.scale.set(1, 1, 1);
 			circleMesh.material.transparent = true;
 			circleMesh.material.opacity = 0;
 			circleMesh.image360 = image360;
-			const group = new THREE.Group();
-			group.add( ringMesh );
-			group.add( circleMesh );
-			images360.node.add(group);
-			image360.circleMesh = circleMesh;
-			image360.ringMesh = ringMesh;
+			const ringGroup = new THREE.Group();
+			ringGroup.add( ringMesh );
+			ringGroup.add( circleMesh );
+			images360.node.add(ringGroup);
+			image360.ringGroup=ringGroup
 		}
 	}
 };
-- 
2.38.1.windows.1


From 0b71001c620095327cfea5b86ed76513bdd95f16 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Thu, 13 Jul 2023 18:56:11 +0530
Subject: [PATCH 11/13] ring displaying condition changed

---
 src/modules/Images360/Images360.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 9eca6a46..189fe367 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -155,7 +155,7 @@ export class Images360 extends EventDispatcher{
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 			let dist = current.distanceTo(next)
-			while(dist < 3 && i<this.images.length) {
+			while(dist < 3 && i<this.images.length-1) {
 				i++
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
-- 
2.38.1.windows.1


From 3dca99a42858ada0dc9b1bc855abad0a7a157572 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 26 Jul 2023 12:59:47 +0530
Subject: [PATCH 12/13] condition is added in Image 360 file and commands file
 is removed

---
 .gitignore                         |  2 +-
 commands.txt                       | 19 -------------------
 src/modules/Images360/Images360.js |  5 +++--
 3 files changed, 4 insertions(+), 22 deletions(-)
 delete mode 100644 commands.txt

diff --git a/.gitignore b/.gitignore
index 6931aa9e..aaa1ed5f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,7 +15,7 @@ libs/CesiumUnminified
 /examples/page.html
 /resources/icons/index.html
 /examples/page.html
-
+/commands.txt
 /pointclouds/retz
 /pointclouds/NVIDIA_Ph01-20160403_tiles_converted
 /pointclouds/D
diff --git a/commands.txt b/commands.txt
deleted file mode 100644
index ddfbd1a3..00000000
--- a/commands.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-curl -v 'https://developer.api.autodesk.com/authentication/v1/authenticate' -X 'POST' -H 'Content-Type: application/x-www-form-urlencoded' -d 'client_id=aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM&client_secret=mSqemcEE53l4THBJ&grant_type=client_credentials&scope=data:read%20data:write%20viewables:read%20bucket:create%20bucket:read'
-
-eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA
-
-curl -v 'https://developer.api.autodesk.com/oss/v2/buckets' -X 'POST' -H 'Content-Type: application/json' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsImtpZCI6Imp3dF9zeW1tZXRyaWNfa2V5In0.eyJjbGllbnRfaWQiOiJpWFdZbTNGVkdNaExZTHNzQVFBd2RNR01xNUhzQXdOYiIsImV4cCI6MTU4NTEyMTY0NSwic2NvcGUiOlsiZGF0YTpyZWFkIiwiZGF0YTp3cml0ZSIsInZpZXdhYmxlczpyZWFkIiwiYnVja2V0OmNyZWF0ZSIsImJ1Y2tldDpyZWFkIl0sImF1ZCI6Imh0dHBzOi8vYXV0b2Rlc2suY29tL2F1ZC9qd3RleHA2MCIsImp0aSI6Im10VklEWGtrOUJwUVBUYU84UlpEV3NWNWpCSHR3VkRObUIwVlN3dnJVeXFiNTVveFlibW5vaUNsMk02Vks4Ym4ifQ.71YkbtExiXDVkWeGODigBWGViNj9_5RSHwTjgvd_MME' -d '{"bucketKey":"threeforge","policyKey":"transient"}'
-digitaltwins
-Verify Bucket
-curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/details' -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA'
-
-
-curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/objects/floor_4.ifc' -X 'PUT' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/octet-stream' -T 'floor_4.ifc'
-
-urn:adsk.objects:os.object:dtwin/floor_4.ifc
-
-dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=
-
-curl -X 'POST' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/json' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/job' -d '{"input": {"urn": "dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM="},"output":{"formats":[{"type":"svf","views":["2d","3d"]}]}}'
-
-curl -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=/manifest'
\ No newline at end of file
diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 189fe367..b547c404 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -151,6 +151,8 @@ export class Images360 extends EventDispatcher{
 			}
 			
 		}
+		if(index!=this.images.length-1)
+		{
 			let i = index + 1
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
@@ -165,7 +167,7 @@ export class Images360 extends EventDispatcher{
 			this.images[i].ringGroup.visible = true
 			this.visibleRings.push(this.images[i])	
 			}
-		
+		}
 		this.selectingEnabled = true;
 		
 		this.sphere.visible = false;
@@ -401,4 +403,3 @@ export class Images360Loader{
 	}
 };
 
-
-- 
2.38.1.windows.1


From 35e4d807c7b307b58d3814790b2b6dd4c13ad1a8 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 26 Jul 2023 13:05:02 +0530
Subject: [PATCH 13/13] In oriented Images remove thumbnails code and added the
 loadeimage code

---
 src/modules/OrientedImages/OrientedImages.js | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
index 4da9cd47..a65e1720 100644
--- a/src/modules/OrientedImages/OrientedImages.js
+++ b/src/modules/OrientedImages/OrientedImages.js
@@ -424,7 +424,8 @@ export class OrientedImageLoader {
       }
 
       viewer.scene.orientedImages[0].focused = image;
-      const tmpImagePath = `${imagesPath}/thumbnails/${target.id}`;
+    	const tmpImagePath = `${Potree.resourcePath}/images/loading.jpg`;
+      //const tmpImagePath = `${imagesPath}/thumbnails/${target.id}`;
       let texture = await loadImageTexture(tmpImagePath);
       updateTexture(texture);
       setTimeout(() => {
-- 
2.38.1.windows.1

